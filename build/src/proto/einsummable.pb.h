// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: einsummable.proto

#ifndef PROTOBUF_INCLUDED_einsummable_2eproto
#define PROTOBUF_INCLUDED_einsummable_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_einsummable_2eproto 

namespace protobuf_einsummable_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[47];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_einsummable_2eproto
namespace es_proto {
class Einsummable;
class EinsummableDefaultTypeInternal;
extern EinsummableDefaultTypeInternal _Einsummable_default_instance_;
class EinsummableList;
class EinsummableListDefaultTypeInternal;
extern EinsummableListDefaultTypeInternal _EinsummableList_default_instance_;
class EsInn;
class EsInnDefaultTypeInternal;
extern EsInnDefaultTypeInternal _EsInn_default_instance_;
class Fill;
class FillDefaultTypeInternal;
extern FillDefaultTypeInternal _Fill_default_instance_;
class IEBuildNext;
class IEBuildNextDefaultTypeInternal;
extern IEBuildNextDefaultTypeInternal _IEBuildNext_default_instance_;
class IECloseReaders;
class IECloseReadersDefaultTypeInternal;
extern IECloseReadersDefaultTypeInternal _IECloseReaders_default_instance_;
class IEExecute;
class IEExecuteDefaultTypeInternal;
extern IEExecuteDefaultTypeInternal _IEExecute_default_instance_;
class IEInit;
class IEInitDefaultTypeInternal;
extern IEInitDefaultTypeInternal _IEInit_default_instance_;
class IELoadDataMatrix;
class IELoadDataMatrixDefaultTypeInternal;
extern IELoadDataMatrixDefaultTypeInternal _IELoadDataMatrix_default_instance_;
class IELoadFreqsCis;
class IELoadFreqsCisDefaultTypeInternal;
extern IELoadFreqsCisDefaultTypeInternal _IELoadFreqsCis_default_instance_;
class IELoadMask;
class IELoadMaskDefaultTypeInternal;
extern IELoadMaskDefaultTypeInternal _IELoadMask_default_instance_;
class IELoadWeight;
class IELoadWeightDefaultTypeInternal;
extern IELoadWeightDefaultTypeInternal _IELoadWeight_default_instance_;
class IERandom;
class IERandomDefaultTypeInternal;
extern IERandomDefaultTypeInternal _IERandom_default_instance_;
class InferenceEvent;
class InferenceEventDefaultTypeInternal;
extern InferenceEventDefaultTypeInternal _InferenceEvent_default_instance_;
class InferenceEvents;
class InferenceEventsDefaultTypeInternal;
extern InferenceEventsDefaultTypeInternal _InferenceEvents_default_instance_;
class InnRegionDim;
class InnRegionDimDefaultTypeInternal;
extern InnRegionDimDefaultTypeInternal _InnRegionDim_default_instance_;
class MGAlloc;
class MGAllocDefaultTypeInternal;
extern MGAllocDefaultTypeInternal _MGAlloc_default_instance_;
class MGApply;
class MGApplyDefaultTypeInternal;
extern MGApplyDefaultTypeInternal _MGApply_default_instance_;
class MGConstant;
class MGConstantDefaultTypeInternal;
extern MGConstantDefaultTypeInternal _MGConstant_default_instance_;
class MGDel;
class MGDelDefaultTypeInternal;
extern MGDelDefaultTypeInternal _MGDel_default_instance_;
class MGEvict;
class MGEvictDefaultTypeInternal;
extern MGEvictDefaultTypeInternal _MGEvict_default_instance_;
class MGInputMem;
class MGInputMemDefaultTypeInternal;
extern MGInputMemDefaultTypeInternal _MGInputMem_default_instance_;
class MGInputSto;
class MGInputStoDefaultTypeInternal;
extern MGInputStoDefaultTypeInternal _MGInputSto_default_instance_;
class MGLoad;
class MGLoadDefaultTypeInternal;
extern MGLoadDefaultTypeInternal _MGLoad_default_instance_;
class MGMove;
class MGMoveDefaultTypeInternal;
extern MGMoveDefaultTypeInternal _MGMove_default_instance_;
class MGPartialize;
class MGPartializeDefaultTypeInternal;
extern MGPartializeDefaultTypeInternal _MGPartialize_default_instance_;
class Mem;
class MemDefaultTypeInternal;
extern MemDefaultTypeInternal _Mem_default_instance_;
class MemGraph;
class MemGraphDefaultTypeInternal;
extern MemGraphDefaultTypeInternal _MemGraph_default_instance_;
class MemGraphNode;
class MemGraphNodeDefaultTypeInternal;
extern MemGraphNodeDefaultTypeInternal _MemGraphNode_default_instance_;
class MemLoc;
class MemLocDefaultTypeInternal;
extern MemLocDefaultTypeInternal _MemLoc_default_instance_;
class OutRegionDim;
class OutRegionDimDefaultTypeInternal;
extern OutRegionDimDefaultTypeInternal _OutRegionDim_default_instance_;
class Partdim;
class PartdimDefaultTypeInternal;
extern PartdimDefaultTypeInternal _Partdim_default_instance_;
class Partition;
class PartitionDefaultTypeInternal;
extern PartitionDefaultTypeInternal _Partition_default_instance_;
class Placement;
class PlacementDefaultTypeInternal;
extern PlacementDefaultTypeInternal _Placement_default_instance_;
class Relation;
class RelationDefaultTypeInternal;
extern RelationDefaultTypeInternal _Relation_default_instance_;
class RemapRelations;
class RemapRelationsDefaultTypeInternal;
extern RemapRelationsDefaultTypeInternal _RemapRelations_default_instance_;
class TGApply;
class TGApplyDefaultTypeInternal;
extern TGApplyDefaultTypeInternal _TGApply_default_instance_;
class TGConstant;
class TGConstantDefaultTypeInternal;
extern TGConstantDefaultTypeInternal _TGConstant_default_instance_;
class TGInput;
class TGInputDefaultTypeInternal;
extern TGInputDefaultTypeInternal _TGInput_default_instance_;
class TGMove;
class TGMoveDefaultTypeInternal;
extern TGMoveDefaultTypeInternal _TGMove_default_instance_;
class TGPartialInn;
class TGPartialInnDefaultTypeInternal;
extern TGPartialInnDefaultTypeInternal _TGPartialInn_default_instance_;
class TGPartialUnit;
class TGPartialUnitDefaultTypeInternal;
extern TGPartialUnitDefaultTypeInternal _TGPartialUnit_default_instance_;
class TGPartialize;
class TGPartializeDefaultTypeInternal;
extern TGPartializeDefaultTypeInternal _TGPartialize_default_instance_;
class TaskGraph;
class TaskGraphDefaultTypeInternal;
extern TaskGraphDefaultTypeInternal _TaskGraph_default_instance_;
class TaskGraphNode;
class TaskGraphNodeDefaultTypeInternal;
extern TaskGraphNodeDefaultTypeInternal _TaskGraphNode_default_instance_;
class Touch;
class TouchDefaultTypeInternal;
extern TouchDefaultTypeInternal _Touch_default_instance_;
class TouchDim;
class TouchDimDefaultTypeInternal;
extern TouchDimDefaultTypeInternal _TouchDim_default_instance_;
}  // namespace es_proto
namespace google {
namespace protobuf {
template<> ::es_proto::Einsummable* Arena::CreateMaybeMessage<::es_proto::Einsummable>(Arena*);
template<> ::es_proto::EinsummableList* Arena::CreateMaybeMessage<::es_proto::EinsummableList>(Arena*);
template<> ::es_proto::EsInn* Arena::CreateMaybeMessage<::es_proto::EsInn>(Arena*);
template<> ::es_proto::Fill* Arena::CreateMaybeMessage<::es_proto::Fill>(Arena*);
template<> ::es_proto::IEBuildNext* Arena::CreateMaybeMessage<::es_proto::IEBuildNext>(Arena*);
template<> ::es_proto::IECloseReaders* Arena::CreateMaybeMessage<::es_proto::IECloseReaders>(Arena*);
template<> ::es_proto::IEExecute* Arena::CreateMaybeMessage<::es_proto::IEExecute>(Arena*);
template<> ::es_proto::IEInit* Arena::CreateMaybeMessage<::es_proto::IEInit>(Arena*);
template<> ::es_proto::IELoadDataMatrix* Arena::CreateMaybeMessage<::es_proto::IELoadDataMatrix>(Arena*);
template<> ::es_proto::IELoadFreqsCis* Arena::CreateMaybeMessage<::es_proto::IELoadFreqsCis>(Arena*);
template<> ::es_proto::IELoadMask* Arena::CreateMaybeMessage<::es_proto::IELoadMask>(Arena*);
template<> ::es_proto::IELoadWeight* Arena::CreateMaybeMessage<::es_proto::IELoadWeight>(Arena*);
template<> ::es_proto::IERandom* Arena::CreateMaybeMessage<::es_proto::IERandom>(Arena*);
template<> ::es_proto::InferenceEvent* Arena::CreateMaybeMessage<::es_proto::InferenceEvent>(Arena*);
template<> ::es_proto::InferenceEvents* Arena::CreateMaybeMessage<::es_proto::InferenceEvents>(Arena*);
template<> ::es_proto::InnRegionDim* Arena::CreateMaybeMessage<::es_proto::InnRegionDim>(Arena*);
template<> ::es_proto::MGAlloc* Arena::CreateMaybeMessage<::es_proto::MGAlloc>(Arena*);
template<> ::es_proto::MGApply* Arena::CreateMaybeMessage<::es_proto::MGApply>(Arena*);
template<> ::es_proto::MGConstant* Arena::CreateMaybeMessage<::es_proto::MGConstant>(Arena*);
template<> ::es_proto::MGDel* Arena::CreateMaybeMessage<::es_proto::MGDel>(Arena*);
template<> ::es_proto::MGEvict* Arena::CreateMaybeMessage<::es_proto::MGEvict>(Arena*);
template<> ::es_proto::MGInputMem* Arena::CreateMaybeMessage<::es_proto::MGInputMem>(Arena*);
template<> ::es_proto::MGInputSto* Arena::CreateMaybeMessage<::es_proto::MGInputSto>(Arena*);
template<> ::es_proto::MGLoad* Arena::CreateMaybeMessage<::es_proto::MGLoad>(Arena*);
template<> ::es_proto::MGMove* Arena::CreateMaybeMessage<::es_proto::MGMove>(Arena*);
template<> ::es_proto::MGPartialize* Arena::CreateMaybeMessage<::es_proto::MGPartialize>(Arena*);
template<> ::es_proto::Mem* Arena::CreateMaybeMessage<::es_proto::Mem>(Arena*);
template<> ::es_proto::MemGraph* Arena::CreateMaybeMessage<::es_proto::MemGraph>(Arena*);
template<> ::es_proto::MemGraphNode* Arena::CreateMaybeMessage<::es_proto::MemGraphNode>(Arena*);
template<> ::es_proto::MemLoc* Arena::CreateMaybeMessage<::es_proto::MemLoc>(Arena*);
template<> ::es_proto::OutRegionDim* Arena::CreateMaybeMessage<::es_proto::OutRegionDim>(Arena*);
template<> ::es_proto::Partdim* Arena::CreateMaybeMessage<::es_proto::Partdim>(Arena*);
template<> ::es_proto::Partition* Arena::CreateMaybeMessage<::es_proto::Partition>(Arena*);
template<> ::es_proto::Placement* Arena::CreateMaybeMessage<::es_proto::Placement>(Arena*);
template<> ::es_proto::Relation* Arena::CreateMaybeMessage<::es_proto::Relation>(Arena*);
template<> ::es_proto::RemapRelations* Arena::CreateMaybeMessage<::es_proto::RemapRelations>(Arena*);
template<> ::es_proto::TGApply* Arena::CreateMaybeMessage<::es_proto::TGApply>(Arena*);
template<> ::es_proto::TGConstant* Arena::CreateMaybeMessage<::es_proto::TGConstant>(Arena*);
template<> ::es_proto::TGInput* Arena::CreateMaybeMessage<::es_proto::TGInput>(Arena*);
template<> ::es_proto::TGMove* Arena::CreateMaybeMessage<::es_proto::TGMove>(Arena*);
template<> ::es_proto::TGPartialInn* Arena::CreateMaybeMessage<::es_proto::TGPartialInn>(Arena*);
template<> ::es_proto::TGPartialUnit* Arena::CreateMaybeMessage<::es_proto::TGPartialUnit>(Arena*);
template<> ::es_proto::TGPartialize* Arena::CreateMaybeMessage<::es_proto::TGPartialize>(Arena*);
template<> ::es_proto::TaskGraph* Arena::CreateMaybeMessage<::es_proto::TaskGraph>(Arena*);
template<> ::es_proto::TaskGraphNode* Arena::CreateMaybeMessage<::es_proto::TaskGraphNode>(Arena*);
template<> ::es_proto::Touch* Arena::CreateMaybeMessage<::es_proto::Touch>(Arena*);
template<> ::es_proto::TouchDim* Arena::CreateMaybeMessage<::es_proto::TouchDim>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace es_proto {

// ===================================================================

class EsInn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.EsInn) */ {
 public:
  EsInn();
  virtual ~EsInn();

  EsInn(const EsInn& from);

  inline EsInn& operator=(const EsInn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EsInn(EsInn&& from) noexcept
    : EsInn() {
    *this = ::std::move(from);
  }

  inline EsInn& operator=(EsInn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EsInn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EsInn* internal_default_instance() {
    return reinterpret_cast<const EsInn*>(
               &_EsInn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EsInn* other);
  friend void swap(EsInn& a, EsInn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EsInn* New() const final {
    return CreateMaybeMessage<EsInn>(NULL);
  }

  EsInn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EsInn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EsInn& from);
  void MergeFrom(const EsInn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EsInn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 idxs = 1;
  int idxs_size() const;
  void clear_idxs();
  static const int kIdxsFieldNumber = 1;
  ::google::protobuf::int32 idxs(int index) const;
  void set_idxs(int index, ::google::protobuf::int32 value);
  void add_idxs(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      idxs() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_idxs();

  // @@protoc_insertion_point(class_scope:es_proto.EsInn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > idxs_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Einsummable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.Einsummable) */ {
 public:
  Einsummable();
  virtual ~Einsummable();

  Einsummable(const Einsummable& from);

  inline Einsummable& operator=(const Einsummable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Einsummable(Einsummable&& from) noexcept
    : Einsummable() {
    *this = ::std::move(from);
  }

  inline Einsummable& operator=(Einsummable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Einsummable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Einsummable* internal_default_instance() {
    return reinterpret_cast<const Einsummable*>(
               &_Einsummable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Einsummable* other);
  friend void swap(Einsummable& a, Einsummable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Einsummable* New() const final {
    return CreateMaybeMessage<Einsummable>(NULL);
  }

  Einsummable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Einsummable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Einsummable& from);
  void MergeFrom(const Einsummable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Einsummable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 join_shape = 1;
  int join_shape_size() const;
  void clear_join_shape();
  static const int kJoinShapeFieldNumber = 1;
  ::google::protobuf::uint64 join_shape(int index) const;
  void set_join_shape(int index, ::google::protobuf::uint64 value);
  void add_join_shape(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      join_shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_join_shape();

  // repeated .es_proto.EsInn inns = 2;
  int inns_size() const;
  void clear_inns();
  static const int kInnsFieldNumber = 2;
  ::es_proto::EsInn* mutable_inns(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::EsInn >*
      mutable_inns();
  const ::es_proto::EsInn& inns(int index) const;
  ::es_proto::EsInn* add_inns();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::EsInn >&
      inns() const;

  // required string join = 4;
  bool has_join() const;
  void clear_join();
  static const int kJoinFieldNumber = 4;
  const ::std::string& join() const;
  void set_join(const ::std::string& value);
  #if LANG_CXX11
  void set_join(::std::string&& value);
  #endif
  void set_join(const char* value);
  void set_join(const char* value, size_t size);
  ::std::string* mutable_join();
  ::std::string* release_join();
  void set_allocated_join(::std::string* join);

  // optional string castable = 5;
  bool has_castable() const;
  void clear_castable();
  static const int kCastableFieldNumber = 5;
  const ::std::string& castable() const;
  void set_castable(const ::std::string& value);
  #if LANG_CXX11
  void set_castable(::std::string&& value);
  #endif
  void set_castable(const char* value);
  void set_castable(const char* value, size_t size);
  ::std::string* mutable_castable();
  ::std::string* release_castable();
  void set_allocated_castable(::std::string* castable);

  // required int32 out_rank = 3;
  bool has_out_rank() const;
  void clear_out_rank();
  static const int kOutRankFieldNumber = 3;
  ::google::protobuf::int32 out_rank() const;
  void set_out_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.Einsummable)
 private:
  void set_has_out_rank();
  void clear_has_out_rank();
  void set_has_join();
  void clear_has_join();
  void set_has_castable();
  void clear_has_castable();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > join_shape_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::EsInn > inns_;
  ::google::protobuf::internal::ArenaStringPtr join_;
  ::google::protobuf::internal::ArenaStringPtr castable_;
  ::google::protobuf::int32 out_rank_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EinsummableList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.EinsummableList) */ {
 public:
  EinsummableList();
  virtual ~EinsummableList();

  EinsummableList(const EinsummableList& from);

  inline EinsummableList& operator=(const EinsummableList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EinsummableList(EinsummableList&& from) noexcept
    : EinsummableList() {
    *this = ::std::move(from);
  }

  inline EinsummableList& operator=(EinsummableList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EinsummableList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EinsummableList* internal_default_instance() {
    return reinterpret_cast<const EinsummableList*>(
               &_EinsummableList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(EinsummableList* other);
  friend void swap(EinsummableList& a, EinsummableList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EinsummableList* New() const final {
    return CreateMaybeMessage<EinsummableList>(NULL);
  }

  EinsummableList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EinsummableList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EinsummableList& from);
  void MergeFrom(const EinsummableList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EinsummableList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.Einsummable es = 1;
  int es_size() const;
  void clear_es();
  static const int kEsFieldNumber = 1;
  ::es_proto::Einsummable* mutable_es(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::Einsummable >*
      mutable_es();
  const ::es_proto::Einsummable& es(int index) const;
  ::es_proto::Einsummable* add_es();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::Einsummable >&
      es() const;

  // @@protoc_insertion_point(class_scope:es_proto.EinsummableList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::Einsummable > es_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TouchDim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TouchDim) */ {
 public:
  TouchDim();
  virtual ~TouchDim();

  TouchDim(const TouchDim& from);

  inline TouchDim& operator=(const TouchDim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TouchDim(TouchDim&& from) noexcept
    : TouchDim() {
    *this = ::std::move(from);
  }

  inline TouchDim& operator=(TouchDim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TouchDim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TouchDim* internal_default_instance() {
    return reinterpret_cast<const TouchDim*>(
               &_TouchDim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TouchDim* other);
  friend void swap(TouchDim& a, TouchDim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TouchDim* New() const final {
    return CreateMaybeMessage<TouchDim>(NULL);
  }

  TouchDim* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TouchDim>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TouchDim& from);
  void MergeFrom(const TouchDim& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchDim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 d_inn = 1;
  bool has_d_inn() const;
  void clear_d_inn();
  static const int kDInnFieldNumber = 1;
  ::google::protobuf::uint64 d_inn() const;
  void set_d_inn(::google::protobuf::uint64 value);

  // required uint64 d_out = 2;
  bool has_d_out() const;
  void clear_d_out();
  static const int kDOutFieldNumber = 2;
  ::google::protobuf::uint64 d_out() const;
  void set_d_out(::google::protobuf::uint64 value);

  // required uint64 offset_inn = 3;
  bool has_offset_inn() const;
  void clear_offset_inn();
  static const int kOffsetInnFieldNumber = 3;
  ::google::protobuf::uint64 offset_inn() const;
  void set_offset_inn(::google::protobuf::uint64 value);

  // required uint64 offset_out = 4;
  bool has_offset_out() const;
  void clear_offset_out();
  static const int kOffsetOutFieldNumber = 4;
  ::google::protobuf::uint64 offset_out() const;
  void set_offset_out(::google::protobuf::uint64 value);

  // required uint64 size = 5;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 5;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.TouchDim)
 private:
  void set_has_d_inn();
  void clear_has_d_inn();
  void set_has_d_out();
  void clear_has_d_out();
  void set_has_offset_inn();
  void clear_has_offset_inn();
  void set_has_offset_out();
  void clear_has_offset_out();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 d_inn_;
  ::google::protobuf::uint64 d_out_;
  ::google::protobuf::uint64 offset_inn_;
  ::google::protobuf::uint64 offset_out_;
  ::google::protobuf::uint64 size_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Touch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.Touch) */ {
 public:
  Touch();
  virtual ~Touch();

  Touch(const Touch& from);

  inline Touch& operator=(const Touch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Touch(Touch&& from) noexcept
    : Touch() {
    *this = ::std::move(from);
  }

  inline Touch& operator=(Touch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Touch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Touch* internal_default_instance() {
    return reinterpret_cast<const Touch*>(
               &_Touch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Touch* other);
  friend void swap(Touch& a, Touch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Touch* New() const final {
    return CreateMaybeMessage<Touch>(NULL);
  }

  Touch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Touch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Touch& from);
  void MergeFrom(const Touch& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Touch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.TouchDim selection = 1;
  int selection_size() const;
  void clear_selection();
  static const int kSelectionFieldNumber = 1;
  ::es_proto::TouchDim* mutable_selection(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::TouchDim >*
      mutable_selection();
  const ::es_proto::TouchDim& selection(int index) const;
  ::es_proto::TouchDim* add_selection();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::TouchDim >&
      selection() const;

  // optional string castable = 2;
  bool has_castable() const;
  void clear_castable();
  static const int kCastableFieldNumber = 2;
  const ::std::string& castable() const;
  void set_castable(const ::std::string& value);
  #if LANG_CXX11
  void set_castable(::std::string&& value);
  #endif
  void set_castable(const char* value);
  void set_castable(const char* value, size_t size);
  ::std::string* mutable_castable();
  ::std::string* release_castable();
  void set_allocated_castable(::std::string* castable);

  // required string dtype = 3;
  bool has_dtype() const;
  void clear_dtype();
  static const int kDtypeFieldNumber = 3;
  const ::std::string& dtype() const;
  void set_dtype(const ::std::string& value);
  #if LANG_CXX11
  void set_dtype(::std::string&& value);
  #endif
  void set_dtype(const char* value);
  void set_dtype(const char* value, size_t size);
  ::std::string* mutable_dtype();
  ::std::string* release_dtype();
  void set_allocated_dtype(::std::string* dtype);

  // @@protoc_insertion_point(class_scope:es_proto.Touch)
 private:
  void set_has_castable();
  void clear_has_castable();
  void set_has_dtype();
  void clear_has_dtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::TouchDim > selection_;
  ::google::protobuf::internal::ArenaStringPtr castable_;
  ::google::protobuf::internal::ArenaStringPtr dtype_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Fill : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.Fill) */ {
 public:
  Fill();
  virtual ~Fill();

  Fill(const Fill& from);

  inline Fill& operator=(const Fill& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fill(Fill&& from) noexcept
    : Fill() {
    *this = ::std::move(from);
  }

  inline Fill& operator=(Fill&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fill& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fill* internal_default_instance() {
    return reinterpret_cast<const Fill*>(
               &_Fill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Fill* other);
  friend void swap(Fill& a, Fill& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fill* New() const final {
    return CreateMaybeMessage<Fill>(NULL);
  }

  Fill* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Fill>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Fill& from);
  void MergeFrom(const Fill& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fill* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 shape = 2;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  ::google::protobuf::uint64 shape(int index) const;
  void set_shape(int index, ::google::protobuf::uint64 value);
  void add_shape(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_shape();

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:es_proto.Fill)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > shape_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TGInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TGInput) */ {
 public:
  TGInput();
  virtual ~TGInput();

  TGInput(const TGInput& from);

  inline TGInput& operator=(const TGInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TGInput(TGInput&& from) noexcept
    : TGInput() {
    *this = ::std::move(from);
  }

  inline TGInput& operator=(TGInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TGInput* internal_default_instance() {
    return reinterpret_cast<const TGInput*>(
               &_TGInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TGInput* other);
  friend void swap(TGInput& a, TGInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TGInput* New() const final {
    return CreateMaybeMessage<TGInput>(NULL);
  }

  TGInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TGInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TGInput& from);
  void MergeFrom(const TGInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.TGInput)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TGApply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TGApply) */ {
 public:
  TGApply();
  virtual ~TGApply();

  TGApply(const TGApply& from);

  inline TGApply& operator=(const TGApply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TGApply(TGApply&& from) noexcept
    : TGApply() {
    *this = ::std::move(from);
  }

  inline TGApply& operator=(TGApply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGApply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TGApply* internal_default_instance() {
    return reinterpret_cast<const TGApply*>(
               &_TGApply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TGApply* other);
  friend void swap(TGApply& a, TGApply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TGApply* New() const final {
    return CreateMaybeMessage<TGApply>(NULL);
  }

  TGApply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TGApply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TGApply& from);
  void MergeFrom(const TGApply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGApply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 inns = 2;
  int inns_size() const;
  void clear_inns();
  static const int kInnsFieldNumber = 2;
  ::google::protobuf::int32 inns(int index) const;
  void set_inns(int index, ::google::protobuf::int32 value);
  void add_inns(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      inns() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_inns();

  // required .es_proto.Einsummable einsummable = 3;
  bool has_einsummable() const;
  void clear_einsummable();
  static const int kEinsummableFieldNumber = 3;
  private:
  const ::es_proto::Einsummable& _internal_einsummable() const;
  public:
  const ::es_proto::Einsummable& einsummable() const;
  ::es_proto::Einsummable* release_einsummable();
  ::es_proto::Einsummable* mutable_einsummable();
  void set_allocated_einsummable(::es_proto::Einsummable* einsummable);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.TGApply)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_einsummable();
  void clear_has_einsummable();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > inns_;
  ::es_proto::Einsummable* einsummable_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TGMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TGMove) */ {
 public:
  TGMove();
  virtual ~TGMove();

  TGMove(const TGMove& from);

  inline TGMove& operator=(const TGMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TGMove(TGMove&& from) noexcept
    : TGMove() {
    *this = ::std::move(from);
  }

  inline TGMove& operator=(TGMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TGMove* internal_default_instance() {
    return reinterpret_cast<const TGMove*>(
               &_TGMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TGMove* other);
  friend void swap(TGMove& a, TGMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TGMove* New() const final {
    return CreateMaybeMessage<TGMove>(NULL);
  }

  TGMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TGMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TGMove& from);
  void MergeFrom(const TGMove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  ::google::protobuf::int32 src() const;
  void set_src(::google::protobuf::int32 value);

  // required int32 dst = 2;
  bool has_dst() const;
  void clear_dst();
  static const int kDstFieldNumber = 2;
  ::google::protobuf::int32 dst() const;
  void set_dst(::google::protobuf::int32 value);

  // required uint64 size = 4;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 inn = 3;
  bool has_inn() const;
  void clear_inn();
  static const int kInnFieldNumber = 3;
  ::google::protobuf::int32 inn() const;
  void set_inn(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.TGMove)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_dst();
  void clear_has_dst();
  void set_has_inn();
  void clear_has_inn();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 src_;
  ::google::protobuf::int32 dst_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 inn_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TGConstant : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TGConstant) */ {
 public:
  TGConstant();
  virtual ~TGConstant();

  TGConstant(const TGConstant& from);

  inline TGConstant& operator=(const TGConstant& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TGConstant(TGConstant&& from) noexcept
    : TGConstant() {
    *this = ::std::move(from);
  }

  inline TGConstant& operator=(TGConstant&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGConstant& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TGConstant* internal_default_instance() {
    return reinterpret_cast<const TGConstant*>(
               &_TGConstant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(TGConstant* other);
  friend void swap(TGConstant& a, TGConstant& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TGConstant* New() const final {
    return CreateMaybeMessage<TGConstant>(NULL);
  }

  TGConstant* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TGConstant>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TGConstant& from);
  void MergeFrom(const TGConstant& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGConstant* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .es_proto.Fill fill = 2;
  bool has_fill() const;
  void clear_fill();
  static const int kFillFieldNumber = 2;
  private:
  const ::es_proto::Fill& _internal_fill() const;
  public:
  const ::es_proto::Fill& fill() const;
  ::es_proto::Fill* release_fill();
  ::es_proto::Fill* mutable_fill();
  void set_allocated_fill(::es_proto::Fill* fill);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.TGConstant)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_fill();
  void clear_has_fill();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::es_proto::Fill* fill_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InnRegionDim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.InnRegionDim) */ {
 public:
  InnRegionDim();
  virtual ~InnRegionDim();

  InnRegionDim(const InnRegionDim& from);

  inline InnRegionDim& operator=(const InnRegionDim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InnRegionDim(InnRegionDim&& from) noexcept
    : InnRegionDim() {
    *this = ::std::move(from);
  }

  inline InnRegionDim& operator=(InnRegionDim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnRegionDim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InnRegionDim* internal_default_instance() {
    return reinterpret_cast<const InnRegionDim*>(
               &_InnRegionDim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(InnRegionDim* other);
  friend void swap(InnRegionDim& a, InnRegionDim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InnRegionDim* New() const final {
    return CreateMaybeMessage<InnRegionDim>(NULL);
  }

  InnRegionDim* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InnRegionDim>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InnRegionDim& from);
  void MergeFrom(const InnRegionDim& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnRegionDim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 dim = 1;
  bool has_dim() const;
  void clear_dim();
  static const int kDimFieldNumber = 1;
  ::google::protobuf::uint64 dim() const;
  void set_dim(::google::protobuf::uint64 value);

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.InnRegionDim)
 private:
  void set_has_dim();
  void clear_has_dim();
  void set_has_offset();
  void clear_has_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 dim_;
  ::google::protobuf::uint64 offset_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OutRegionDim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.OutRegionDim) */ {
 public:
  OutRegionDim();
  virtual ~OutRegionDim();

  OutRegionDim(const OutRegionDim& from);

  inline OutRegionDim& operator=(const OutRegionDim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutRegionDim(OutRegionDim&& from) noexcept
    : OutRegionDim() {
    *this = ::std::move(from);
  }

  inline OutRegionDim& operator=(OutRegionDim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutRegionDim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutRegionDim* internal_default_instance() {
    return reinterpret_cast<const OutRegionDim*>(
               &_OutRegionDim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(OutRegionDim* other);
  friend void swap(OutRegionDim& a, OutRegionDim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutRegionDim* New() const final {
    return CreateMaybeMessage<OutRegionDim>(NULL);
  }

  OutRegionDim* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OutRegionDim>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OutRegionDim& from);
  void MergeFrom(const OutRegionDim& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutRegionDim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.OutRegionDim)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TGPartialInn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TGPartialInn) */ {
 public:
  TGPartialInn();
  virtual ~TGPartialInn();

  TGPartialInn(const TGPartialInn& from);

  inline TGPartialInn& operator=(const TGPartialInn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TGPartialInn(TGPartialInn&& from) noexcept
    : TGPartialInn() {
    *this = ::std::move(from);
  }

  inline TGPartialInn& operator=(TGPartialInn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGPartialInn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TGPartialInn* internal_default_instance() {
    return reinterpret_cast<const TGPartialInn*>(
               &_TGPartialInn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(TGPartialInn* other);
  friend void swap(TGPartialInn& a, TGPartialInn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TGPartialInn* New() const final {
    return CreateMaybeMessage<TGPartialInn>(NULL);
  }

  TGPartialInn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TGPartialInn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TGPartialInn& from);
  void MergeFrom(const TGPartialInn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGPartialInn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.InnRegionDim region = 3;
  int region_size() const;
  void clear_region();
  static const int kRegionFieldNumber = 3;
  ::es_proto::InnRegionDim* mutable_region(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::InnRegionDim >*
      mutable_region();
  const ::es_proto::InnRegionDim& region(int index) const;
  ::es_proto::InnRegionDim* add_region();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::InnRegionDim >&
      region() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required bool consumable = 2;
  bool has_consumable() const;
  void clear_consumable();
  static const int kConsumableFieldNumber = 2;
  bool consumable() const;
  void set_consumable(bool value);

  // @@protoc_insertion_point(class_scope:es_proto.TGPartialInn)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_consumable();
  void clear_has_consumable();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::InnRegionDim > region_;
  ::google::protobuf::int32 id_;
  bool consumable_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TGPartialUnit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TGPartialUnit) */ {
 public:
  TGPartialUnit();
  virtual ~TGPartialUnit();

  TGPartialUnit(const TGPartialUnit& from);

  inline TGPartialUnit& operator=(const TGPartialUnit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TGPartialUnit(TGPartialUnit&& from) noexcept
    : TGPartialUnit() {
    *this = ::std::move(from);
  }

  inline TGPartialUnit& operator=(TGPartialUnit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGPartialUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TGPartialUnit* internal_default_instance() {
    return reinterpret_cast<const TGPartialUnit*>(
               &_TGPartialUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TGPartialUnit* other);
  friend void swap(TGPartialUnit& a, TGPartialUnit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TGPartialUnit* New() const final {
    return CreateMaybeMessage<TGPartialUnit>(NULL);
  }

  TGPartialUnit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TGPartialUnit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TGPartialUnit& from);
  void MergeFrom(const TGPartialUnit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGPartialUnit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.OutRegionDim out_region = 2;
  int out_region_size() const;
  void clear_out_region();
  static const int kOutRegionFieldNumber = 2;
  ::es_proto::OutRegionDim* mutable_out_region(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::OutRegionDim >*
      mutable_out_region();
  const ::es_proto::OutRegionDim& out_region(int index) const;
  ::es_proto::OutRegionDim* add_out_region();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::OutRegionDim >&
      out_region() const;

  // repeated .es_proto.TGPartialInn inputs = 3;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 3;
  ::es_proto::TGPartialInn* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialInn >*
      mutable_inputs();
  const ::es_proto::TGPartialInn& inputs(int index) const;
  ::es_proto::TGPartialInn* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialInn >&
      inputs() const;

  // optional string castable = 1;
  bool has_castable() const;
  void clear_castable();
  static const int kCastableFieldNumber = 1;
  const ::std::string& castable() const;
  void set_castable(const ::std::string& value);
  #if LANG_CXX11
  void set_castable(::std::string&& value);
  #endif
  void set_castable(const char* value);
  void set_castable(const char* value, size_t size);
  ::std::string* mutable_castable();
  ::std::string* release_castable();
  void set_allocated_castable(::std::string* castable);

  // @@protoc_insertion_point(class_scope:es_proto.TGPartialUnit)
 private:
  void set_has_castable();
  void clear_has_castable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::OutRegionDim > out_region_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialInn > inputs_;
  ::google::protobuf::internal::ArenaStringPtr castable_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TGPartialize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TGPartialize) */ {
 public:
  TGPartialize();
  virtual ~TGPartialize();

  TGPartialize(const TGPartialize& from);

  inline TGPartialize& operator=(const TGPartialize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TGPartialize(TGPartialize&& from) noexcept
    : TGPartialize() {
    *this = ::std::move(from);
  }

  inline TGPartialize& operator=(TGPartialize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGPartialize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TGPartialize* internal_default_instance() {
    return reinterpret_cast<const TGPartialize*>(
               &_TGPartialize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TGPartialize* other);
  friend void swap(TGPartialize& a, TGPartialize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TGPartialize* New() const final {
    return CreateMaybeMessage<TGPartialize>(NULL);
  }

  TGPartialize* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TGPartialize>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TGPartialize& from);
  void MergeFrom(const TGPartialize& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGPartialize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 write_shape = 3;
  int write_shape_size() const;
  void clear_write_shape();
  static const int kWriteShapeFieldNumber = 3;
  ::google::protobuf::uint64 write_shape(int index) const;
  void set_write_shape(int index, ::google::protobuf::uint64 value);
  void add_write_shape(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      write_shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_write_shape();

  // repeated .es_proto.TGPartialUnit units = 4;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 4;
  ::es_proto::TGPartialUnit* mutable_units(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialUnit >*
      mutable_units();
  const ::es_proto::TGPartialUnit& units(int index) const;
  ::es_proto::TGPartialUnit* add_units();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialUnit >&
      units() const;

  // required string dtype = 2;
  bool has_dtype() const;
  void clear_dtype();
  static const int kDtypeFieldNumber = 2;
  const ::std::string& dtype() const;
  void set_dtype(const ::std::string& value);
  #if LANG_CXX11
  void set_dtype(::std::string&& value);
  #endif
  void set_dtype(const char* value);
  void set_dtype(const char* value, size_t size);
  ::std::string* mutable_dtype();
  ::std::string* release_dtype();
  void set_allocated_dtype(::std::string* dtype);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.TGPartialize)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_dtype();
  void clear_has_dtype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > write_shape_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialUnit > units_;
  ::google::protobuf::internal::ArenaStringPtr dtype_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskGraphNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TaskGraphNode) */ {
 public:
  TaskGraphNode();
  virtual ~TaskGraphNode();

  TaskGraphNode(const TaskGraphNode& from);

  inline TaskGraphNode& operator=(const TaskGraphNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskGraphNode(TaskGraphNode&& from) noexcept
    : TaskGraphNode() {
    *this = ::std::move(from);
  }

  inline TaskGraphNode& operator=(TaskGraphNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskGraphNode& default_instance();

  enum NodeCase {
    kInput = 1,
    kApply = 2,
    kMove = 3,
    kConstant = 4,
    kPartialize = 5,
    NODE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskGraphNode* internal_default_instance() {
    return reinterpret_cast<const TaskGraphNode*>(
               &_TaskGraphNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(TaskGraphNode* other);
  friend void swap(TaskGraphNode& a, TaskGraphNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskGraphNode* New() const final {
    return CreateMaybeMessage<TaskGraphNode>(NULL);
  }

  TaskGraphNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskGraphNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskGraphNode& from);
  void MergeFrom(const TaskGraphNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskGraphNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_save = 6;
  bool has_is_save() const;
  void clear_is_save();
  static const int kIsSaveFieldNumber = 6;
  bool is_save() const;
  void set_is_save(bool value);

  // optional .es_proto.TGInput input = 1;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  private:
  const ::es_proto::TGInput& _internal_input() const;
  public:
  const ::es_proto::TGInput& input() const;
  ::es_proto::TGInput* release_input();
  ::es_proto::TGInput* mutable_input();
  void set_allocated_input(::es_proto::TGInput* input);

  // optional .es_proto.TGApply apply = 2;
  bool has_apply() const;
  void clear_apply();
  static const int kApplyFieldNumber = 2;
  private:
  const ::es_proto::TGApply& _internal_apply() const;
  public:
  const ::es_proto::TGApply& apply() const;
  ::es_proto::TGApply* release_apply();
  ::es_proto::TGApply* mutable_apply();
  void set_allocated_apply(::es_proto::TGApply* apply);

  // optional .es_proto.TGMove move = 3;
  bool has_move() const;
  void clear_move();
  static const int kMoveFieldNumber = 3;
  private:
  const ::es_proto::TGMove& _internal_move() const;
  public:
  const ::es_proto::TGMove& move() const;
  ::es_proto::TGMove* release_move();
  ::es_proto::TGMove* mutable_move();
  void set_allocated_move(::es_proto::TGMove* move);

  // optional .es_proto.TGConstant constant = 4;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 4;
  private:
  const ::es_proto::TGConstant& _internal_constant() const;
  public:
  const ::es_proto::TGConstant& constant() const;
  ::es_proto::TGConstant* release_constant();
  ::es_proto::TGConstant* mutable_constant();
  void set_allocated_constant(::es_proto::TGConstant* constant);

  // optional .es_proto.TGPartialize partialize = 5;
  bool has_partialize() const;
  void clear_partialize();
  static const int kPartializeFieldNumber = 5;
  private:
  const ::es_proto::TGPartialize& _internal_partialize() const;
  public:
  const ::es_proto::TGPartialize& partialize() const;
  ::es_proto::TGPartialize* release_partialize();
  ::es_proto::TGPartialize* mutable_partialize();
  void set_allocated_partialize(::es_proto::TGPartialize* partialize);

  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:es_proto.TaskGraphNode)
 private:
  void set_has_input();
  void set_has_apply();
  void set_has_move();
  void set_has_constant();
  void set_has_partialize();
  void set_has_is_save();
  void clear_has_is_save();

  inline bool has_node() const;
  inline void clear_has_node();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool is_save_;
  union NodeUnion {
    NodeUnion() {}
    ::es_proto::TGInput* input_;
    ::es_proto::TGApply* apply_;
    ::es_proto::TGMove* move_;
    ::es_proto::TGConstant* constant_;
    ::es_proto::TGPartialize* partialize_;
  } node_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskGraph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.TaskGraph) */ {
 public:
  TaskGraph();
  virtual ~TaskGraph();

  TaskGraph(const TaskGraph& from);

  inline TaskGraph& operator=(const TaskGraph& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskGraph(TaskGraph&& from) noexcept
    : TaskGraph() {
    *this = ::std::move(from);
  }

  inline TaskGraph& operator=(TaskGraph&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskGraph& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskGraph* internal_default_instance() {
    return reinterpret_cast<const TaskGraph*>(
               &_TaskGraph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(TaskGraph* other);
  friend void swap(TaskGraph& a, TaskGraph& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskGraph* New() const final {
    return CreateMaybeMessage<TaskGraph>(NULL);
  }

  TaskGraph* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskGraph>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskGraph& from);
  void MergeFrom(const TaskGraph& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskGraph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.TaskGraphNode nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::es_proto::TaskGraphNode* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::TaskGraphNode >*
      mutable_nodes();
  const ::es_proto::TaskGraphNode& nodes(int index) const;
  ::es_proto::TaskGraphNode* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::TaskGraphNode >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:es_proto.TaskGraph)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::TaskGraphNode > nodes_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Partdim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.Partdim) */ {
 public:
  Partdim();
  virtual ~Partdim();

  Partdim(const Partdim& from);

  inline Partdim& operator=(const Partdim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Partdim(Partdim&& from) noexcept
    : Partdim() {
    *this = ::std::move(from);
  }

  inline Partdim& operator=(Partdim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Partdim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Partdim* internal_default_instance() {
    return reinterpret_cast<const Partdim*>(
               &_Partdim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Partdim* other);
  friend void swap(Partdim& a, Partdim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Partdim* New() const final {
    return CreateMaybeMessage<Partdim>(NULL);
  }

  Partdim* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Partdim>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Partdim& from);
  void MergeFrom(const Partdim& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partdim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 spans = 1;
  int spans_size() const;
  void clear_spans();
  static const int kSpansFieldNumber = 1;
  ::google::protobuf::uint64 spans(int index) const;
  void set_spans(int index, ::google::protobuf::uint64 value);
  void add_spans(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      spans() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_spans();

  // @@protoc_insertion_point(class_scope:es_proto.Partdim)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > spans_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Partition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.Partition) */ {
 public:
  Partition();
  virtual ~Partition();

  Partition(const Partition& from);

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Partition(Partition&& from) noexcept
    : Partition() {
    *this = ::std::move(from);
  }

  inline Partition& operator=(Partition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Partition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Partition* internal_default_instance() {
    return reinterpret_cast<const Partition*>(
               &_Partition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Partition* other);
  friend void swap(Partition& a, Partition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Partition* New() const final {
    return CreateMaybeMessage<Partition>(NULL);
  }

  Partition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Partition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Partition& from);
  void MergeFrom(const Partition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.Partdim partdims = 1;
  int partdims_size() const;
  void clear_partdims();
  static const int kPartdimsFieldNumber = 1;
  ::es_proto::Partdim* mutable_partdims(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::Partdim >*
      mutable_partdims();
  const ::es_proto::Partdim& partdims(int index) const;
  ::es_proto::Partdim* add_partdims();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::Partdim >&
      partdims() const;

  // @@protoc_insertion_point(class_scope:es_proto.Partition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::Partdim > partdims_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Placement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.Placement) */ {
 public:
  Placement();
  virtual ~Placement();

  Placement(const Placement& from);

  inline Placement& operator=(const Placement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Placement(Placement&& from) noexcept
    : Placement() {
    *this = ::std::move(from);
  }

  inline Placement& operator=(Placement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Placement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Placement* internal_default_instance() {
    return reinterpret_cast<const Placement*>(
               &_Placement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Placement* other);
  friend void swap(Placement& a, Placement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Placement* New() const final {
    return CreateMaybeMessage<Placement>(NULL);
  }

  Placement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Placement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Placement& from);
  void MergeFrom(const Placement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Placement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 locations = 2;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 2;
  ::google::protobuf::int32 locations(int index) const;
  void set_locations(int index, ::google::protobuf::int32 value);
  void add_locations(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      locations() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_locations();

  // required .es_proto.Partition partition = 1;
  bool has_partition() const;
  void clear_partition();
  static const int kPartitionFieldNumber = 1;
  private:
  const ::es_proto::Partition& _internal_partition() const;
  public:
  const ::es_proto::Partition& partition() const;
  ::es_proto::Partition* release_partition();
  ::es_proto::Partition* mutable_partition();
  void set_allocated_partition(::es_proto::Partition* partition);

  // @@protoc_insertion_point(class_scope:es_proto.Placement)
 private:
  void set_has_partition();
  void clear_has_partition();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > locations_;
  ::es_proto::Partition* partition_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Relation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.Relation) */ {
 public:
  Relation();
  virtual ~Relation();

  Relation(const Relation& from);

  inline Relation& operator=(const Relation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Relation(Relation&& from) noexcept
    : Relation() {
    *this = ::std::move(from);
  }

  inline Relation& operator=(Relation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Relation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Relation* internal_default_instance() {
    return reinterpret_cast<const Relation*>(
               &_Relation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Relation* other);
  friend void swap(Relation& a, Relation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Relation* New() const final {
    return CreateMaybeMessage<Relation>(NULL);
  }

  Relation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Relation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Relation& from);
  void MergeFrom(const Relation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Relation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 tids = 4;
  int tids_size() const;
  void clear_tids();
  static const int kTidsFieldNumber = 4;
  ::google::protobuf::int32 tids(int index) const;
  void set_tids(int index, ::google::protobuf::int32 value);
  void add_tids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tids();

  // required string dtype = 1;
  bool has_dtype() const;
  void clear_dtype();
  static const int kDtypeFieldNumber = 1;
  const ::std::string& dtype() const;
  void set_dtype(const ::std::string& value);
  #if LANG_CXX11
  void set_dtype(::std::string&& value);
  #endif
  void set_dtype(const char* value);
  void set_dtype(const char* value, size_t size);
  ::std::string* mutable_dtype();
  ::std::string* release_dtype();
  void set_allocated_dtype(::std::string* dtype);

  // required .es_proto.Placement placement = 2;
  bool has_placement() const;
  void clear_placement();
  static const int kPlacementFieldNumber = 2;
  private:
  const ::es_proto::Placement& _internal_placement() const;
  public:
  const ::es_proto::Placement& placement() const;
  ::es_proto::Placement* release_placement();
  ::es_proto::Placement* mutable_placement();
  void set_allocated_placement(::es_proto::Placement* placement);

  // @@protoc_insertion_point(class_scope:es_proto.Relation)
 private:
  void set_has_dtype();
  void clear_has_dtype();
  void set_has_placement();
  void clear_has_placement();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tids_;
  ::google::protobuf::internal::ArenaStringPtr dtype_;
  ::es_proto::Placement* placement_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemapRelations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.RemapRelations) */ {
 public:
  RemapRelations();
  virtual ~RemapRelations();

  RemapRelations(const RemapRelations& from);

  inline RemapRelations& operator=(const RemapRelations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemapRelations(RemapRelations&& from) noexcept
    : RemapRelations() {
    *this = ::std::move(from);
  }

  inline RemapRelations& operator=(RemapRelations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemapRelations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemapRelations* internal_default_instance() {
    return reinterpret_cast<const RemapRelations*>(
               &_RemapRelations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(RemapRelations* other);
  friend void swap(RemapRelations& a, RemapRelations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemapRelations* New() const final {
    return CreateMaybeMessage<RemapRelations>(NULL);
  }

  RemapRelations* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemapRelations>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RemapRelations& from);
  void MergeFrom(const RemapRelations& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemapRelations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.Relation srcs = 1;
  int srcs_size() const;
  void clear_srcs();
  static const int kSrcsFieldNumber = 1;
  ::es_proto::Relation* mutable_srcs(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::Relation >*
      mutable_srcs();
  const ::es_proto::Relation& srcs(int index) const;
  ::es_proto::Relation* add_srcs();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::Relation >&
      srcs() const;

  // repeated .es_proto.Relation dsts = 2;
  int dsts_size() const;
  void clear_dsts();
  static const int kDstsFieldNumber = 2;
  ::es_proto::Relation* mutable_dsts(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::Relation >*
      mutable_dsts();
  const ::es_proto::Relation& dsts(int index) const;
  ::es_proto::Relation* add_dsts();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::Relation >&
      dsts() const;

  // @@protoc_insertion_point(class_scope:es_proto.RemapRelations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::Relation > srcs_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::Relation > dsts_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGInputMem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGInputMem) */ {
 public:
  MGInputMem();
  virtual ~MGInputMem();

  MGInputMem(const MGInputMem& from);

  inline MGInputMem& operator=(const MGInputMem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGInputMem(MGInputMem&& from) noexcept
    : MGInputMem() {
    *this = ::std::move(from);
  }

  inline MGInputMem& operator=(MGInputMem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGInputMem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGInputMem* internal_default_instance() {
    return reinterpret_cast<const MGInputMem*>(
               &_MGInputMem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(MGInputMem* other);
  friend void swap(MGInputMem& a, MGInputMem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGInputMem* New() const final {
    return CreateMaybeMessage<MGInputMem>(NULL);
  }

  MGInputMem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGInputMem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGInputMem& from);
  void MergeFrom(const MGInputMem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGInputMem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGInputMem)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGInputSto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGInputSto) */ {
 public:
  MGInputSto();
  virtual ~MGInputSto();

  MGInputSto(const MGInputSto& from);

  inline MGInputSto& operator=(const MGInputSto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGInputSto(MGInputSto&& from) noexcept
    : MGInputSto() {
    *this = ::std::move(from);
  }

  inline MGInputSto& operator=(MGInputSto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGInputSto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGInputSto* internal_default_instance() {
    return reinterpret_cast<const MGInputSto*>(
               &_MGInputSto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(MGInputSto* other);
  friend void swap(MGInputSto& a, MGInputSto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGInputSto* New() const final {
    return CreateMaybeMessage<MGInputSto>(NULL);
  }

  MGInputSto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGInputSto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGInputSto& from);
  void MergeFrom(const MGInputSto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGInputSto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storage_loc = 1;
  bool has_storage_loc() const;
  void clear_storage_loc();
  static const int kStorageLocFieldNumber = 1;
  ::google::protobuf::int32 storage_loc() const;
  void set_storage_loc(::google::protobuf::int32 value);

  // required int32 storage_id = 2;
  bool has_storage_id() const;
  void clear_storage_id();
  static const int kStorageIdFieldNumber = 2;
  ::google::protobuf::int32 storage_id() const;
  void set_storage_id(::google::protobuf::int32 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGInputSto)
 private:
  void set_has_storage_loc();
  void clear_has_storage_loc();
  void set_has_storage_id();
  void clear_has_storage_id();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 storage_loc_;
  ::google::protobuf::int32 storage_id_;
  ::google::protobuf::uint64 size_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGConstant : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGConstant) */ {
 public:
  MGConstant();
  virtual ~MGConstant();

  MGConstant(const MGConstant& from);

  inline MGConstant& operator=(const MGConstant& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGConstant(MGConstant&& from) noexcept
    : MGConstant() {
    *this = ::std::move(from);
  }

  inline MGConstant& operator=(MGConstant&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGConstant& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGConstant* internal_default_instance() {
    return reinterpret_cast<const MGConstant*>(
               &_MGConstant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(MGConstant* other);
  friend void swap(MGConstant& a, MGConstant& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGConstant* New() const final {
    return CreateMaybeMessage<MGConstant>(NULL);
  }

  MGConstant* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGConstant>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGConstant& from);
  void MergeFrom(const MGConstant& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGConstant* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .es_proto.Fill fill = 3;
  bool has_fill() const;
  void clear_fill();
  static const int kFillFieldNumber = 3;
  private:
  const ::es_proto::Fill& _internal_fill() const;
  public:
  const ::es_proto::Fill& fill() const;
  ::es_proto::Fill* release_fill();
  ::es_proto::Fill* mutable_fill();
  void set_allocated_fill(::es_proto::Fill* fill);

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGConstant)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_offset();
  void clear_has_offset();
  void set_has_fill();
  void clear_has_fill();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::es_proto::Fill* fill_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGApply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGApply) */ {
 public:
  MGApply();
  virtual ~MGApply();

  MGApply(const MGApply& from);

  inline MGApply& operator=(const MGApply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGApply(MGApply&& from) noexcept
    : MGApply() {
    *this = ::std::move(from);
  }

  inline MGApply& operator=(MGApply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGApply& default_instance();

  enum OpCase {
    kEinsummable = 4,
    kTouch = 5,
    OP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGApply* internal_default_instance() {
    return reinterpret_cast<const MGApply*>(
               &_MGApply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(MGApply* other);
  friend void swap(MGApply& a, MGApply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGApply* New() const final {
    return CreateMaybeMessage<MGApply>(NULL);
  }

  MGApply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGApply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGApply& from);
  void MergeFrom(const MGApply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGApply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 mems_offset = 2;
  int mems_offset_size() const;
  void clear_mems_offset();
  static const int kMemsOffsetFieldNumber = 2;
  ::google::protobuf::uint64 mems_offset(int index) const;
  void set_mems_offset(int index, ::google::protobuf::uint64 value);
  void add_mems_offset(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      mems_offset() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_mems_offset();

  // repeated uint64 mems_size = 3;
  int mems_size_size() const;
  void clear_mems_size();
  static const int kMemsSizeFieldNumber = 3;
  ::google::protobuf::uint64 mems_size(int index) const;
  void set_mems_size(int index, ::google::protobuf::uint64 value);
  void add_mems_size(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      mems_size() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_mems_size();

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // required int32 group = 6;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 6;
  ::google::protobuf::int32 group() const;
  void set_group(::google::protobuf::int32 value);

  // optional .es_proto.Einsummable einsummable = 4;
  bool has_einsummable() const;
  void clear_einsummable();
  static const int kEinsummableFieldNumber = 4;
  private:
  const ::es_proto::Einsummable& _internal_einsummable() const;
  public:
  const ::es_proto::Einsummable& einsummable() const;
  ::es_proto::Einsummable* release_einsummable();
  ::es_proto::Einsummable* mutable_einsummable();
  void set_allocated_einsummable(::es_proto::Einsummable* einsummable);

  // optional .es_proto.Touch touch = 5;
  bool has_touch() const;
  void clear_touch();
  static const int kTouchFieldNumber = 5;
  private:
  const ::es_proto::Touch& _internal_touch() const;
  public:
  const ::es_proto::Touch& touch() const;
  ::es_proto::Touch* release_touch();
  ::es_proto::Touch* mutable_touch();
  void set_allocated_touch(::es_proto::Touch* touch);

  void clear_op();
  OpCase op_case() const;
  // @@protoc_insertion_point(class_scope:es_proto.MGApply)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_einsummable();
  void set_has_touch();
  void set_has_group();
  void clear_has_group();

  inline bool has_op() const;
  inline void clear_has_op();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > mems_offset_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > mems_size_;
  ::google::protobuf::int32 loc_;
  ::google::protobuf::int32 group_;
  union OpUnion {
    OpUnion() {}
    ::es_proto::Einsummable* einsummable_;
    ::es_proto::Touch* touch_;
  } op_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGMove) */ {
 public:
  MGMove();
  virtual ~MGMove();

  MGMove(const MGMove& from);

  inline MGMove& operator=(const MGMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGMove(MGMove&& from) noexcept
    : MGMove() {
    *this = ::std::move(from);
  }

  inline MGMove& operator=(MGMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGMove* internal_default_instance() {
    return reinterpret_cast<const MGMove*>(
               &_MGMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(MGMove* other);
  friend void swap(MGMove& a, MGMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGMove* New() const final {
    return CreateMaybeMessage<MGMove>(NULL);
  }

  MGMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGMove& from);
  void MergeFrom(const MGMove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 src_offset = 2;
  bool has_src_offset() const;
  void clear_src_offset();
  static const int kSrcOffsetFieldNumber = 2;
  ::google::protobuf::uint64 src_offset() const;
  void set_src_offset(::google::protobuf::uint64 value);

  // required int32 src_loc = 1;
  bool has_src_loc() const;
  void clear_src_loc();
  static const int kSrcLocFieldNumber = 1;
  ::google::protobuf::int32 src_loc() const;
  void set_src_loc(::google::protobuf::int32 value);

  // required int32 dst_loc = 3;
  bool has_dst_loc() const;
  void clear_dst_loc();
  static const int kDstLocFieldNumber = 3;
  ::google::protobuf::int32 dst_loc() const;
  void set_dst_loc(::google::protobuf::int32 value);

  // required uint64 dst_offset = 4;
  bool has_dst_offset() const;
  void clear_dst_offset();
  static const int kDstOffsetFieldNumber = 4;
  ::google::protobuf::uint64 dst_offset() const;
  void set_dst_offset(::google::protobuf::uint64 value);

  // required uint64 size = 5;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 5;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGMove)
 private:
  void set_has_src_loc();
  void clear_has_src_loc();
  void set_has_src_offset();
  void clear_has_src_offset();
  void set_has_dst_loc();
  void clear_has_dst_loc();
  void set_has_dst_offset();
  void clear_has_dst_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 src_offset_;
  ::google::protobuf::int32 src_loc_;
  ::google::protobuf::int32 dst_loc_;
  ::google::protobuf::uint64 dst_offset_;
  ::google::protobuf::uint64 size_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGEvict : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGEvict) */ {
 public:
  MGEvict();
  virtual ~MGEvict();

  MGEvict(const MGEvict& from);

  inline MGEvict& operator=(const MGEvict& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGEvict(MGEvict&& from) noexcept
    : MGEvict() {
    *this = ::std::move(from);
  }

  inline MGEvict& operator=(MGEvict&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGEvict& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGEvict* internal_default_instance() {
    return reinterpret_cast<const MGEvict*>(
               &_MGEvict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(MGEvict* other);
  friend void swap(MGEvict& a, MGEvict& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGEvict* New() const final {
    return CreateMaybeMessage<MGEvict>(NULL);
  }

  MGEvict* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGEvict>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGEvict& from);
  void MergeFrom(const MGEvict& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGEvict* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storage_loc = 1;
  bool has_storage_loc() const;
  void clear_storage_loc();
  static const int kStorageLocFieldNumber = 1;
  ::google::protobuf::int32 storage_loc() const;
  void set_storage_loc(::google::protobuf::int32 value);

  // required int32 storage_id = 2;
  bool has_storage_id() const;
  void clear_storage_id();
  static const int kStorageIdFieldNumber = 2;
  ::google::protobuf::int32 storage_id() const;
  void set_storage_id(::google::protobuf::int32 value);

  // required uint64 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 5;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 5;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 loc = 3;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 3;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGEvict)
 private:
  void set_has_storage_loc();
  void clear_has_storage_loc();
  void set_has_storage_id();
  void clear_has_storage_id();
  void set_has_loc();
  void clear_has_loc();
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 storage_loc_;
  ::google::protobuf::int32 storage_id_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGLoad) */ {
 public:
  MGLoad();
  virtual ~MGLoad();

  MGLoad(const MGLoad& from);

  inline MGLoad& operator=(const MGLoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGLoad(MGLoad&& from) noexcept
    : MGLoad() {
    *this = ::std::move(from);
  }

  inline MGLoad& operator=(MGLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGLoad* internal_default_instance() {
    return reinterpret_cast<const MGLoad*>(
               &_MGLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(MGLoad* other);
  friend void swap(MGLoad& a, MGLoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGLoad* New() const final {
    return CreateMaybeMessage<MGLoad>(NULL);
  }

  MGLoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGLoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGLoad& from);
  void MergeFrom(const MGLoad& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 storage_loc = 1;
  bool has_storage_loc() const;
  void clear_storage_loc();
  static const int kStorageLocFieldNumber = 1;
  ::google::protobuf::int32 storage_loc() const;
  void set_storage_loc(::google::protobuf::int32 value);

  // required int32 storage_id = 2;
  bool has_storage_id() const;
  void clear_storage_id();
  static const int kStorageIdFieldNumber = 2;
  ::google::protobuf::int32 storage_id() const;
  void set_storage_id(::google::protobuf::int32 value);

  // required uint64 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 5;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 5;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 loc = 3;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 3;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGLoad)
 private:
  void set_has_storage_loc();
  void clear_has_storage_loc();
  void set_has_storage_id();
  void clear_has_storage_id();
  void set_has_loc();
  void clear_has_loc();
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 storage_loc_;
  ::google::protobuf::int32 storage_id_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGPartialize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGPartialize) */ {
 public:
  MGPartialize();
  virtual ~MGPartialize();

  MGPartialize(const MGPartialize& from);

  inline MGPartialize& operator=(const MGPartialize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGPartialize(MGPartialize&& from) noexcept
    : MGPartialize() {
    *this = ::std::move(from);
  }

  inline MGPartialize& operator=(MGPartialize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGPartialize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGPartialize* internal_default_instance() {
    return reinterpret_cast<const MGPartialize*>(
               &_MGPartialize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(MGPartialize* other);
  friend void swap(MGPartialize& a, MGPartialize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGPartialize* New() const final {
    return CreateMaybeMessage<MGPartialize>(NULL);
  }

  MGPartialize* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGPartialize>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGPartialize& from);
  void MergeFrom(const MGPartialize& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGPartialize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGPartialize)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGAlloc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGAlloc) */ {
 public:
  MGAlloc();
  virtual ~MGAlloc();

  MGAlloc(const MGAlloc& from);

  inline MGAlloc& operator=(const MGAlloc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGAlloc(MGAlloc&& from) noexcept
    : MGAlloc() {
    *this = ::std::move(from);
  }

  inline MGAlloc& operator=(MGAlloc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGAlloc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGAlloc* internal_default_instance() {
    return reinterpret_cast<const MGAlloc*>(
               &_MGAlloc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(MGAlloc* other);
  friend void swap(MGAlloc& a, MGAlloc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGAlloc* New() const final {
    return CreateMaybeMessage<MGAlloc>(NULL);
  }

  MGAlloc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGAlloc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGAlloc& from);
  void MergeFrom(const MGAlloc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGAlloc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGAlloc)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MGDel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MGDel) */ {
 public:
  MGDel();
  virtual ~MGDel();

  MGDel(const MGDel& from);

  inline MGDel& operator=(const MGDel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MGDel(MGDel&& from) noexcept
    : MGDel() {
    *this = ::std::move(from);
  }

  inline MGDel& operator=(MGDel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MGDel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MGDel* internal_default_instance() {
    return reinterpret_cast<const MGDel*>(
               &_MGDel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(MGDel* other);
  friend void swap(MGDel& a, MGDel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MGDel* New() const final {
    return CreateMaybeMessage<MGDel>(NULL);
  }

  MGDel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MGDel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MGDel& from);
  void MergeFrom(const MGDel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MGDel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 loc = 1;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 1;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MGDel)
 private:
  void set_has_loc();
  void clear_has_loc();
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemGraphNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MemGraphNode) */ {
 public:
  MemGraphNode();
  virtual ~MemGraphNode();

  MemGraphNode(const MemGraphNode& from);

  inline MemGraphNode& operator=(const MemGraphNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemGraphNode(MemGraphNode&& from) noexcept
    : MemGraphNode() {
    *this = ::std::move(from);
  }

  inline MemGraphNode& operator=(MemGraphNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemGraphNode& default_instance();

  enum NodeCase {
    kInputmem = 1,
    kInputsto = 2,
    kConstant = 3,
    kApply = 4,
    kMove = 5,
    kEvict = 6,
    kLoad = 7,
    kPartialize = 8,
    kAlloc = 9,
    kDel = 10,
    NODE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemGraphNode* internal_default_instance() {
    return reinterpret_cast<const MemGraphNode*>(
               &_MemGraphNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(MemGraphNode* other);
  friend void swap(MemGraphNode& a, MemGraphNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemGraphNode* New() const final {
    return CreateMaybeMessage<MemGraphNode>(NULL);
  }

  MemGraphNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemGraphNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemGraphNode& from);
  void MergeFrom(const MemGraphNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemGraphNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 inns = 11;
  int inns_size() const;
  void clear_inns();
  static const int kInnsFieldNumber = 11;
  ::google::protobuf::int32 inns(int index) const;
  void set_inns(int index, ::google::protobuf::int32 value);
  void add_inns(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      inns() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_inns();

  // optional .es_proto.MGInputMem inputmem = 1;
  bool has_inputmem() const;
  void clear_inputmem();
  static const int kInputmemFieldNumber = 1;
  private:
  const ::es_proto::MGInputMem& _internal_inputmem() const;
  public:
  const ::es_proto::MGInputMem& inputmem() const;
  ::es_proto::MGInputMem* release_inputmem();
  ::es_proto::MGInputMem* mutable_inputmem();
  void set_allocated_inputmem(::es_proto::MGInputMem* inputmem);

  // optional .es_proto.MGInputSto inputsto = 2;
  bool has_inputsto() const;
  void clear_inputsto();
  static const int kInputstoFieldNumber = 2;
  private:
  const ::es_proto::MGInputSto& _internal_inputsto() const;
  public:
  const ::es_proto::MGInputSto& inputsto() const;
  ::es_proto::MGInputSto* release_inputsto();
  ::es_proto::MGInputSto* mutable_inputsto();
  void set_allocated_inputsto(::es_proto::MGInputSto* inputsto);

  // optional .es_proto.MGConstant constant = 3;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 3;
  private:
  const ::es_proto::MGConstant& _internal_constant() const;
  public:
  const ::es_proto::MGConstant& constant() const;
  ::es_proto::MGConstant* release_constant();
  ::es_proto::MGConstant* mutable_constant();
  void set_allocated_constant(::es_proto::MGConstant* constant);

  // optional .es_proto.MGApply apply = 4;
  bool has_apply() const;
  void clear_apply();
  static const int kApplyFieldNumber = 4;
  private:
  const ::es_proto::MGApply& _internal_apply() const;
  public:
  const ::es_proto::MGApply& apply() const;
  ::es_proto::MGApply* release_apply();
  ::es_proto::MGApply* mutable_apply();
  void set_allocated_apply(::es_proto::MGApply* apply);

  // optional .es_proto.MGMove move = 5;
  bool has_move() const;
  void clear_move();
  static const int kMoveFieldNumber = 5;
  private:
  const ::es_proto::MGMove& _internal_move() const;
  public:
  const ::es_proto::MGMove& move() const;
  ::es_proto::MGMove* release_move();
  ::es_proto::MGMove* mutable_move();
  void set_allocated_move(::es_proto::MGMove* move);

  // optional .es_proto.MGEvict evict = 6;
  bool has_evict() const;
  void clear_evict();
  static const int kEvictFieldNumber = 6;
  private:
  const ::es_proto::MGEvict& _internal_evict() const;
  public:
  const ::es_proto::MGEvict& evict() const;
  ::es_proto::MGEvict* release_evict();
  ::es_proto::MGEvict* mutable_evict();
  void set_allocated_evict(::es_proto::MGEvict* evict);

  // optional .es_proto.MGLoad load = 7;
  bool has_load() const;
  void clear_load();
  static const int kLoadFieldNumber = 7;
  private:
  const ::es_proto::MGLoad& _internal_load() const;
  public:
  const ::es_proto::MGLoad& load() const;
  ::es_proto::MGLoad* release_load();
  ::es_proto::MGLoad* mutable_load();
  void set_allocated_load(::es_proto::MGLoad* load);

  // optional .es_proto.MGPartialize partialize = 8;
  bool has_partialize() const;
  void clear_partialize();
  static const int kPartializeFieldNumber = 8;
  private:
  const ::es_proto::MGPartialize& _internal_partialize() const;
  public:
  const ::es_proto::MGPartialize& partialize() const;
  ::es_proto::MGPartialize* release_partialize();
  ::es_proto::MGPartialize* mutable_partialize();
  void set_allocated_partialize(::es_proto::MGPartialize* partialize);

  // optional .es_proto.MGAlloc alloc = 9;
  bool has_alloc() const;
  void clear_alloc();
  static const int kAllocFieldNumber = 9;
  private:
  const ::es_proto::MGAlloc& _internal_alloc() const;
  public:
  const ::es_proto::MGAlloc& alloc() const;
  ::es_proto::MGAlloc* release_alloc();
  ::es_proto::MGAlloc* mutable_alloc();
  void set_allocated_alloc(::es_proto::MGAlloc* alloc);

  // optional .es_proto.MGDel del = 10;
  bool has_del() const;
  void clear_del();
  static const int kDelFieldNumber = 10;
  private:
  const ::es_proto::MGDel& _internal_del() const;
  public:
  const ::es_proto::MGDel& del() const;
  ::es_proto::MGDel* release_del();
  ::es_proto::MGDel* mutable_del();
  void set_allocated_del(::es_proto::MGDel* del);

  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:es_proto.MemGraphNode)
 private:
  void set_has_inputmem();
  void set_has_inputsto();
  void set_has_constant();
  void set_has_apply();
  void set_has_move();
  void set_has_evict();
  void set_has_load();
  void set_has_partialize();
  void set_has_alloc();
  void set_has_del();

  inline bool has_node() const;
  inline void clear_has_node();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > inns_;
  union NodeUnion {
    NodeUnion() {}
    ::es_proto::MGInputMem* inputmem_;
    ::es_proto::MGInputSto* inputsto_;
    ::es_proto::MGConstant* constant_;
    ::es_proto::MGApply* apply_;
    ::es_proto::MGMove* move_;
    ::es_proto::MGEvict* evict_;
    ::es_proto::MGLoad* load_;
    ::es_proto::MGPartialize* partialize_;
    ::es_proto::MGAlloc* alloc_;
    ::es_proto::MGDel* del_;
  } node_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemGraph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MemGraph) */ {
 public:
  MemGraph();
  virtual ~MemGraph();

  MemGraph(const MemGraph& from);

  inline MemGraph& operator=(const MemGraph& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemGraph(MemGraph&& from) noexcept
    : MemGraph() {
    *this = ::std::move(from);
  }

  inline MemGraph& operator=(MemGraph&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemGraph& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemGraph* internal_default_instance() {
    return reinterpret_cast<const MemGraph*>(
               &_MemGraph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(MemGraph* other);
  friend void swap(MemGraph& a, MemGraph& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemGraph* New() const final {
    return CreateMaybeMessage<MemGraph>(NULL);
  }

  MemGraph* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemGraph>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemGraph& from);
  void MergeFrom(const MemGraph& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemGraph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 storage_locs = 3;
  int storage_locs_size() const;
  void clear_storage_locs();
  static const int kStorageLocsFieldNumber = 3;
  ::google::protobuf::int32 storage_locs(int index) const;
  void set_storage_locs(int index, ::google::protobuf::int32 value);
  void add_storage_locs(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      storage_locs() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_storage_locs();

  // repeated .es_proto.MemGraphNode nodes = 4;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 4;
  ::es_proto::MemGraphNode* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemGraphNode >*
      mutable_nodes();
  const ::es_proto::MemGraphNode& nodes(int index) const;
  ::es_proto::MemGraphNode* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::MemGraphNode >&
      nodes() const;

  // required int32 num_compute_locs = 1;
  bool has_num_compute_locs() const;
  void clear_num_compute_locs();
  static const int kNumComputeLocsFieldNumber = 1;
  ::google::protobuf::int32 num_compute_locs() const;
  void set_num_compute_locs(::google::protobuf::int32 value);

  // required int32 num_storage_locs = 2;
  bool has_num_storage_locs() const;
  void clear_num_storage_locs();
  static const int kNumStorageLocsFieldNumber = 2;
  ::google::protobuf::int32 num_storage_locs() const;
  void set_num_storage_locs(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MemGraph)
 private:
  void set_has_num_compute_locs();
  void clear_has_num_compute_locs();
  void set_has_num_storage_locs();
  void clear_has_num_storage_locs();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > storage_locs_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemGraphNode > nodes_;
  ::google::protobuf::int32 num_compute_locs_;
  ::google::protobuf::int32 num_storage_locs_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.Mem) */ {
 public:
  Mem();
  virtual ~Mem();

  Mem(const Mem& from);

  inline Mem& operator=(const Mem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mem(Mem&& from) noexcept
    : Mem() {
    *this = ::std::move(from);
  }

  inline Mem& operator=(Mem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mem* internal_default_instance() {
    return reinterpret_cast<const Mem*>(
               &_Mem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(Mem* other);
  friend void swap(Mem& a, Mem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mem* New() const final {
    return CreateMaybeMessage<Mem>(NULL);
  }

  Mem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mem& from);
  void MergeFrom(const Mem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.Mem)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemLoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.MemLoc) */ {
 public:
  MemLoc();
  virtual ~MemLoc();

  MemLoc(const MemLoc& from);

  inline MemLoc& operator=(const MemLoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemLoc(MemLoc&& from) noexcept
    : MemLoc() {
    *this = ::std::move(from);
  }

  inline MemLoc& operator=(MemLoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemLoc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemLoc* internal_default_instance() {
    return reinterpret_cast<const MemLoc*>(
               &_MemLoc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(MemLoc* other);
  friend void swap(MemLoc& a, MemLoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemLoc* New() const final {
    return CreateMaybeMessage<MemLoc>(NULL);
  }

  MemLoc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemLoc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemLoc& from);
  void MergeFrom(const MemLoc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemLoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required int32 loc = 3;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 3;
  ::google::protobuf::int32 loc() const;
  void set_loc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.MemLoc)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_size();
  void clear_has_size();
  void set_has_loc();
  void clear_has_loc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 loc_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IEInit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IEInit) */ {
 public:
  IEInit();
  virtual ~IEInit();

  IEInit(const IEInit& from);

  inline IEInit& operator=(const IEInit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IEInit(IEInit&& from) noexcept
    : IEInit() {
    *this = ::std::move(from);
  }

  inline IEInit& operator=(IEInit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IEInit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IEInit* internal_default_instance() {
    return reinterpret_cast<const IEInit*>(
               &_IEInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(IEInit* other);
  friend void swap(IEInit& a, IEInit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IEInit* New() const final {
    return CreateMaybeMessage<IEInit>(NULL);
  }

  IEInit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IEInit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IEInit& from);
  void MergeFrom(const IEInit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IEInit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 mem_size = 2;
  bool has_mem_size() const;
  void clear_mem_size();
  static const int kMemSizeFieldNumber = 2;
  ::google::protobuf::uint64 mem_size() const;
  void set_mem_size(::google::protobuf::uint64 value);

  // required int32 world_size = 1;
  bool has_world_size() const;
  void clear_world_size();
  static const int kWorldSizeFieldNumber = 1;
  ::google::protobuf::int32 world_size() const;
  void set_world_size(::google::protobuf::int32 value);

  // required int32 num_threads = 3;
  bool has_num_threads() const;
  void clear_num_threads();
  static const int kNumThreadsFieldNumber = 3;
  ::google::protobuf::int32 num_threads() const;
  void set_num_threads(::google::protobuf::int32 value);

  // required uint64 batch_size = 5;
  bool has_batch_size() const;
  void clear_batch_size();
  static const int kBatchSizeFieldNumber = 5;
  ::google::protobuf::uint64 batch_size() const;
  void set_batch_size(::google::protobuf::uint64 value);

  // required uint64 seq_len = 6;
  bool has_seq_len() const;
  void clear_seq_len();
  static const int kSeqLenFieldNumber = 6;
  ::google::protobuf::uint64 seq_len() const;
  void set_seq_len(::google::protobuf::uint64 value);

  // required int32 num_files = 4;
  bool has_num_files() const;
  void clear_num_files();
  static const int kNumFilesFieldNumber = 4;
  ::google::protobuf::int32 num_files() const;
  void set_num_files(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.IEInit)
 private:
  void set_has_world_size();
  void clear_has_world_size();
  void set_has_mem_size();
  void clear_has_mem_size();
  void set_has_num_threads();
  void clear_has_num_threads();
  void set_has_num_files();
  void clear_has_num_files();
  void set_has_batch_size();
  void clear_has_batch_size();
  void set_has_seq_len();
  void clear_has_seq_len();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 mem_size_;
  ::google::protobuf::int32 world_size_;
  ::google::protobuf::int32 num_threads_;
  ::google::protobuf::uint64 batch_size_;
  ::google::protobuf::uint64 seq_len_;
  ::google::protobuf::int32 num_files_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IECloseReaders : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IECloseReaders) */ {
 public:
  IECloseReaders();
  virtual ~IECloseReaders();

  IECloseReaders(const IECloseReaders& from);

  inline IECloseReaders& operator=(const IECloseReaders& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IECloseReaders(IECloseReaders&& from) noexcept
    : IECloseReaders() {
    *this = ::std::move(from);
  }

  inline IECloseReaders& operator=(IECloseReaders&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IECloseReaders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IECloseReaders* internal_default_instance() {
    return reinterpret_cast<const IECloseReaders*>(
               &_IECloseReaders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(IECloseReaders* other);
  friend void swap(IECloseReaders& a, IECloseReaders& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IECloseReaders* New() const final {
    return CreateMaybeMessage<IECloseReaders>(NULL);
  }

  IECloseReaders* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IECloseReaders>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IECloseReaders& from);
  void MergeFrom(const IECloseReaders& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IECloseReaders* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 dummy = 1;
  bool has_dummy() const;
  void clear_dummy();
  static const int kDummyFieldNumber = 1;
  ::google::protobuf::int32 dummy() const;
  void set_dummy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_proto.IECloseReaders)
 private:
  void set_has_dummy();
  void clear_has_dummy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 dummy_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IELoadWeight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IELoadWeight) */ {
 public:
  IELoadWeight();
  virtual ~IELoadWeight();

  IELoadWeight(const IELoadWeight& from);

  inline IELoadWeight& operator=(const IELoadWeight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IELoadWeight(IELoadWeight&& from) noexcept
    : IELoadWeight() {
    *this = ::std::move(from);
  }

  inline IELoadWeight& operator=(IELoadWeight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IELoadWeight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IELoadWeight* internal_default_instance() {
    return reinterpret_cast<const IELoadWeight*>(
               &_IELoadWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(IELoadWeight* other);
  friend void swap(IELoadWeight& a, IELoadWeight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IELoadWeight* New() const final {
    return CreateMaybeMessage<IELoadWeight>(NULL);
  }

  IELoadWeight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IELoadWeight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IELoadWeight& from);
  void MergeFrom(const IELoadWeight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IELoadWeight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.MemLoc data_locs = 2;
  int data_locs_size() const;
  void clear_data_locs();
  static const int kDataLocsFieldNumber = 2;
  ::es_proto::MemLoc* mutable_data_locs(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >*
      mutable_data_locs();
  const ::es_proto::MemLoc& data_locs(int index) const;
  ::es_proto::MemLoc* add_data_locs();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >&
      data_locs() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:es_proto.IELoadWeight)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc > data_locs_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IELoadDataMatrix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IELoadDataMatrix) */ {
 public:
  IELoadDataMatrix();
  virtual ~IELoadDataMatrix();

  IELoadDataMatrix(const IELoadDataMatrix& from);

  inline IELoadDataMatrix& operator=(const IELoadDataMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IELoadDataMatrix(IELoadDataMatrix&& from) noexcept
    : IELoadDataMatrix() {
    *this = ::std::move(from);
  }

  inline IELoadDataMatrix& operator=(IELoadDataMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IELoadDataMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IELoadDataMatrix* internal_default_instance() {
    return reinterpret_cast<const IELoadDataMatrix*>(
               &_IELoadDataMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(IELoadDataMatrix* other);
  friend void swap(IELoadDataMatrix& a, IELoadDataMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IELoadDataMatrix* New() const final {
    return CreateMaybeMessage<IELoadDataMatrix>(NULL);
  }

  IELoadDataMatrix* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IELoadDataMatrix>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IELoadDataMatrix& from);
  void MergeFrom(const IELoadDataMatrix& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IELoadDataMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .es_proto.Mem mem = 4;
  bool has_mem() const;
  void clear_mem();
  static const int kMemFieldNumber = 4;
  private:
  const ::es_proto::Mem& _internal_mem() const;
  public:
  const ::es_proto::Mem& mem() const;
  ::es_proto::Mem* release_mem();
  ::es_proto::Mem* mutable_mem();
  void set_allocated_mem(::es_proto::Mem* mem);

  // required uint64 batch_size = 1;
  bool has_batch_size() const;
  void clear_batch_size();
  static const int kBatchSizeFieldNumber = 1;
  ::google::protobuf::uint64 batch_size() const;
  void set_batch_size(::google::protobuf::uint64 value);

  // required uint64 seq_len = 2;
  bool has_seq_len() const;
  void clear_seq_len();
  static const int kSeqLenFieldNumber = 2;
  ::google::protobuf::uint64 seq_len() const;
  void set_seq_len(::google::protobuf::uint64 value);

  // required uint64 d_embed = 3;
  bool has_d_embed() const;
  void clear_d_embed();
  static const int kDEmbedFieldNumber = 3;
  ::google::protobuf::uint64 d_embed() const;
  void set_d_embed(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.IELoadDataMatrix)
 private:
  void set_has_batch_size();
  void clear_has_batch_size();
  void set_has_seq_len();
  void clear_has_seq_len();
  void set_has_d_embed();
  void clear_has_d_embed();
  void set_has_mem();
  void clear_has_mem();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::es_proto::Mem* mem_;
  ::google::protobuf::uint64 batch_size_;
  ::google::protobuf::uint64 seq_len_;
  ::google::protobuf::uint64 d_embed_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IELoadMask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IELoadMask) */ {
 public:
  IELoadMask();
  virtual ~IELoadMask();

  IELoadMask(const IELoadMask& from);

  inline IELoadMask& operator=(const IELoadMask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IELoadMask(IELoadMask&& from) noexcept
    : IELoadMask() {
    *this = ::std::move(from);
  }

  inline IELoadMask& operator=(IELoadMask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IELoadMask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IELoadMask* internal_default_instance() {
    return reinterpret_cast<const IELoadMask*>(
               &_IELoadMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(IELoadMask* other);
  friend void swap(IELoadMask& a, IELoadMask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IELoadMask* New() const final {
    return CreateMaybeMessage<IELoadMask>(NULL);
  }

  IELoadMask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IELoadMask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IELoadMask& from);
  void MergeFrom(const IELoadMask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IELoadMask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .es_proto.Mem mem = 2;
  bool has_mem() const;
  void clear_mem();
  static const int kMemFieldNumber = 2;
  private:
  const ::es_proto::Mem& _internal_mem() const;
  public:
  const ::es_proto::Mem& mem() const;
  ::es_proto::Mem* release_mem();
  ::es_proto::Mem* mutable_mem();
  void set_allocated_mem(::es_proto::Mem* mem);

  // required uint64 seq_len = 1;
  bool has_seq_len() const;
  void clear_seq_len();
  static const int kSeqLenFieldNumber = 1;
  ::google::protobuf::uint64 seq_len() const;
  void set_seq_len(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.IELoadMask)
 private:
  void set_has_seq_len();
  void clear_has_seq_len();
  void set_has_mem();
  void clear_has_mem();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::es_proto::Mem* mem_;
  ::google::protobuf::uint64 seq_len_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IELoadFreqsCis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IELoadFreqsCis) */ {
 public:
  IELoadFreqsCis();
  virtual ~IELoadFreqsCis();

  IELoadFreqsCis(const IELoadFreqsCis& from);

  inline IELoadFreqsCis& operator=(const IELoadFreqsCis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IELoadFreqsCis(IELoadFreqsCis&& from) noexcept
    : IELoadFreqsCis() {
    *this = ::std::move(from);
  }

  inline IELoadFreqsCis& operator=(IELoadFreqsCis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IELoadFreqsCis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IELoadFreqsCis* internal_default_instance() {
    return reinterpret_cast<const IELoadFreqsCis*>(
               &_IELoadFreqsCis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(IELoadFreqsCis* other);
  friend void swap(IELoadFreqsCis& a, IELoadFreqsCis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IELoadFreqsCis* New() const final {
    return CreateMaybeMessage<IELoadFreqsCis>(NULL);
  }

  IELoadFreqsCis* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IELoadFreqsCis>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IELoadFreqsCis& from);
  void MergeFrom(const IELoadFreqsCis& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IELoadFreqsCis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .es_proto.Mem mem = 4;
  bool has_mem() const;
  void clear_mem();
  static const int kMemFieldNumber = 4;
  private:
  const ::es_proto::Mem& _internal_mem() const;
  public:
  const ::es_proto::Mem& mem() const;
  ::es_proto::Mem* release_mem();
  ::es_proto::Mem* mutable_mem();
  void set_allocated_mem(::es_proto::Mem* mem);

  // required uint64 dim = 1;
  bool has_dim() const;
  void clear_dim();
  static const int kDimFieldNumber = 1;
  ::google::protobuf::uint64 dim() const;
  void set_dim(::google::protobuf::uint64 value);

  // required uint64 heads = 2;
  bool has_heads() const;
  void clear_heads();
  static const int kHeadsFieldNumber = 2;
  ::google::protobuf::uint64 heads() const;
  void set_heads(::google::protobuf::uint64 value);

  // required uint64 max_seq_len = 3;
  bool has_max_seq_len() const;
  void clear_max_seq_len();
  static const int kMaxSeqLenFieldNumber = 3;
  ::google::protobuf::uint64 max_seq_len() const;
  void set_max_seq_len(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:es_proto.IELoadFreqsCis)
 private:
  void set_has_dim();
  void clear_has_dim();
  void set_has_heads();
  void clear_has_heads();
  void set_has_max_seq_len();
  void clear_has_max_seq_len();
  void set_has_mem();
  void clear_has_mem();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::es_proto::Mem* mem_;
  ::google::protobuf::uint64 dim_;
  ::google::protobuf::uint64 heads_;
  ::google::protobuf::uint64 max_seq_len_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IEExecute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IEExecute) */ {
 public:
  IEExecute();
  virtual ~IEExecute();

  IEExecute(const IEExecute& from);

  inline IEExecute& operator=(const IEExecute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IEExecute(IEExecute&& from) noexcept
    : IEExecute() {
    *this = ::std::move(from);
  }

  inline IEExecute& operator=(IEExecute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IEExecute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IEExecute* internal_default_instance() {
    return reinterpret_cast<const IEExecute*>(
               &_IEExecute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(IEExecute* other);
  friend void swap(IEExecute& a, IEExecute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IEExecute* New() const final {
    return CreateMaybeMessage<IEExecute>(NULL);
  }

  IEExecute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IEExecute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IEExecute& from);
  void MergeFrom(const IEExecute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IEExecute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg = 1;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // required .es_proto.MemGraph memgraph = 2;
  bool has_memgraph() const;
  void clear_memgraph();
  static const int kMemgraphFieldNumber = 2;
  private:
  const ::es_proto::MemGraph& _internal_memgraph() const;
  public:
  const ::es_proto::MemGraph& memgraph() const;
  ::es_proto::MemGraph* release_memgraph();
  ::es_proto::MemGraph* mutable_memgraph();
  void set_allocated_memgraph(::es_proto::MemGraph* memgraph);

  // @@protoc_insertion_point(class_scope:es_proto.IEExecute)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_memgraph();
  void clear_has_memgraph();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::es_proto::MemGraph* memgraph_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IEBuildNext : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IEBuildNext) */ {
 public:
  IEBuildNext();
  virtual ~IEBuildNext();

  IEBuildNext(const IEBuildNext& from);

  inline IEBuildNext& operator=(const IEBuildNext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IEBuildNext(IEBuildNext&& from) noexcept
    : IEBuildNext() {
    *this = ::std::move(from);
  }

  inline IEBuildNext& operator=(IEBuildNext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IEBuildNext& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IEBuildNext* internal_default_instance() {
    return reinterpret_cast<const IEBuildNext*>(
               &_IEBuildNext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(IEBuildNext* other);
  friend void swap(IEBuildNext& a, IEBuildNext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IEBuildNext* New() const final {
    return CreateMaybeMessage<IEBuildNext>(NULL);
  }

  IEBuildNext* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IEBuildNext>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IEBuildNext& from);
  void MergeFrom(const IEBuildNext& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IEBuildNext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.MemLoc src_data_locs = 2;
  int src_data_locs_size() const;
  void clear_src_data_locs();
  static const int kSrcDataLocsFieldNumber = 2;
  ::es_proto::MemLoc* mutable_src_data_locs(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >*
      mutable_src_data_locs();
  const ::es_proto::MemLoc& src_data_locs(int index) const;
  ::es_proto::MemLoc* add_src_data_locs();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >&
      src_data_locs() const;

  // repeated .es_proto.MemLoc dst_data_locs = 4;
  int dst_data_locs_size() const;
  void clear_dst_data_locs();
  static const int kDstDataLocsFieldNumber = 4;
  ::es_proto::MemLoc* mutable_dst_data_locs(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >*
      mutable_dst_data_locs();
  const ::es_proto::MemLoc& dst_data_locs(int index) const;
  ::es_proto::MemLoc* add_dst_data_locs();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >&
      dst_data_locs() const;

  // required .es_proto.Partition src_part = 1;
  bool has_src_part() const;
  void clear_src_part();
  static const int kSrcPartFieldNumber = 1;
  private:
  const ::es_proto::Partition& _internal_src_part() const;
  public:
  const ::es_proto::Partition& src_part() const;
  ::es_proto::Partition* release_src_part();
  ::es_proto::Partition* mutable_src_part();
  void set_allocated_src_part(::es_proto::Partition* src_part);

  // required .es_proto.Partition dst_part = 3;
  bool has_dst_part() const;
  void clear_dst_part();
  static const int kDstPartFieldNumber = 3;
  private:
  const ::es_proto::Partition& _internal_dst_part() const;
  public:
  const ::es_proto::Partition& dst_part() const;
  ::es_proto::Partition* release_dst_part();
  ::es_proto::Partition* mutable_dst_part();
  void set_allocated_dst_part(::es_proto::Partition* dst_part);

  // @@protoc_insertion_point(class_scope:es_proto.IEBuildNext)
 private:
  void set_has_src_part();
  void clear_has_src_part();
  void set_has_dst_part();
  void clear_has_dst_part();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc > src_data_locs_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc > dst_data_locs_;
  ::es_proto::Partition* src_part_;
  ::es_proto::Partition* dst_part_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IERandom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.IERandom) */ {
 public:
  IERandom();
  virtual ~IERandom();

  IERandom(const IERandom& from);

  inline IERandom& operator=(const IERandom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IERandom(IERandom&& from) noexcept
    : IERandom() {
    *this = ::std::move(from);
  }

  inline IERandom& operator=(IERandom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IERandom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IERandom* internal_default_instance() {
    return reinterpret_cast<const IERandom*>(
               &_IERandom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(IERandom* other);
  friend void swap(IERandom& a, IERandom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IERandom* New() const final {
    return CreateMaybeMessage<IERandom>(NULL);
  }

  IERandom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IERandom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IERandom& from);
  void MergeFrom(const IERandom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IERandom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.MemLoc mems = 1;
  int mems_size() const;
  void clear_mems();
  static const int kMemsFieldNumber = 1;
  ::es_proto::MemLoc* mutable_mems(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >*
      mutable_mems();
  const ::es_proto::MemLoc& mems(int index) const;
  ::es_proto::MemLoc* add_mems();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >&
      mems() const;

  // @@protoc_insertion_point(class_scope:es_proto.IERandom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc > mems_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InferenceEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.InferenceEvent) */ {
 public:
  InferenceEvent();
  virtual ~InferenceEvent();

  InferenceEvent(const InferenceEvent& from);

  inline InferenceEvent& operator=(const InferenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InferenceEvent(InferenceEvent&& from) noexcept
    : InferenceEvent() {
    *this = ::std::move(from);
  }

  inline InferenceEvent& operator=(InferenceEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InferenceEvent& default_instance();

  enum OpCase {
    kInit = 1,
    kCloseReaders = 2,
    kLoadWeight = 3,
    kLoadDataMatrix = 4,
    kLoadMask = 5,
    kLoadFreqsCis = 6,
    kExecute = 7,
    kBuildNext = 8,
    kRandom = 9,
    OP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InferenceEvent* internal_default_instance() {
    return reinterpret_cast<const InferenceEvent*>(
               &_InferenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(InferenceEvent* other);
  friend void swap(InferenceEvent& a, InferenceEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InferenceEvent* New() const final {
    return CreateMaybeMessage<InferenceEvent>(NULL);
  }

  InferenceEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InferenceEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InferenceEvent& from);
  void MergeFrom(const InferenceEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferenceEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .es_proto.IEInit init = 1;
  bool has_init() const;
  void clear_init();
  static const int kInitFieldNumber = 1;
  private:
  const ::es_proto::IEInit& _internal_init() const;
  public:
  const ::es_proto::IEInit& init() const;
  ::es_proto::IEInit* release_init();
  ::es_proto::IEInit* mutable_init();
  void set_allocated_init(::es_proto::IEInit* init);

  // optional .es_proto.IECloseReaders close_readers = 2;
  bool has_close_readers() const;
  void clear_close_readers();
  static const int kCloseReadersFieldNumber = 2;
  private:
  const ::es_proto::IECloseReaders& _internal_close_readers() const;
  public:
  const ::es_proto::IECloseReaders& close_readers() const;
  ::es_proto::IECloseReaders* release_close_readers();
  ::es_proto::IECloseReaders* mutable_close_readers();
  void set_allocated_close_readers(::es_proto::IECloseReaders* close_readers);

  // optional .es_proto.IELoadWeight load_weight = 3;
  bool has_load_weight() const;
  void clear_load_weight();
  static const int kLoadWeightFieldNumber = 3;
  private:
  const ::es_proto::IELoadWeight& _internal_load_weight() const;
  public:
  const ::es_proto::IELoadWeight& load_weight() const;
  ::es_proto::IELoadWeight* release_load_weight();
  ::es_proto::IELoadWeight* mutable_load_weight();
  void set_allocated_load_weight(::es_proto::IELoadWeight* load_weight);

  // optional .es_proto.IELoadDataMatrix load_data_matrix = 4;
  bool has_load_data_matrix() const;
  void clear_load_data_matrix();
  static const int kLoadDataMatrixFieldNumber = 4;
  private:
  const ::es_proto::IELoadDataMatrix& _internal_load_data_matrix() const;
  public:
  const ::es_proto::IELoadDataMatrix& load_data_matrix() const;
  ::es_proto::IELoadDataMatrix* release_load_data_matrix();
  ::es_proto::IELoadDataMatrix* mutable_load_data_matrix();
  void set_allocated_load_data_matrix(::es_proto::IELoadDataMatrix* load_data_matrix);

  // optional .es_proto.IELoadMask load_mask = 5;
  bool has_load_mask() const;
  void clear_load_mask();
  static const int kLoadMaskFieldNumber = 5;
  private:
  const ::es_proto::IELoadMask& _internal_load_mask() const;
  public:
  const ::es_proto::IELoadMask& load_mask() const;
  ::es_proto::IELoadMask* release_load_mask();
  ::es_proto::IELoadMask* mutable_load_mask();
  void set_allocated_load_mask(::es_proto::IELoadMask* load_mask);

  // optional .es_proto.IELoadFreqsCis load_freqs_cis = 6;
  bool has_load_freqs_cis() const;
  void clear_load_freqs_cis();
  static const int kLoadFreqsCisFieldNumber = 6;
  private:
  const ::es_proto::IELoadFreqsCis& _internal_load_freqs_cis() const;
  public:
  const ::es_proto::IELoadFreqsCis& load_freqs_cis() const;
  ::es_proto::IELoadFreqsCis* release_load_freqs_cis();
  ::es_proto::IELoadFreqsCis* mutable_load_freqs_cis();
  void set_allocated_load_freqs_cis(::es_proto::IELoadFreqsCis* load_freqs_cis);

  // optional .es_proto.IEExecute execute = 7;
  bool has_execute() const;
  void clear_execute();
  static const int kExecuteFieldNumber = 7;
  private:
  const ::es_proto::IEExecute& _internal_execute() const;
  public:
  const ::es_proto::IEExecute& execute() const;
  ::es_proto::IEExecute* release_execute();
  ::es_proto::IEExecute* mutable_execute();
  void set_allocated_execute(::es_proto::IEExecute* execute);

  // optional .es_proto.IEBuildNext build_next = 8;
  bool has_build_next() const;
  void clear_build_next();
  static const int kBuildNextFieldNumber = 8;
  private:
  const ::es_proto::IEBuildNext& _internal_build_next() const;
  public:
  const ::es_proto::IEBuildNext& build_next() const;
  ::es_proto::IEBuildNext* release_build_next();
  ::es_proto::IEBuildNext* mutable_build_next();
  void set_allocated_build_next(::es_proto::IEBuildNext* build_next);

  // optional .es_proto.IERandom random = 9;
  bool has_random() const;
  void clear_random();
  static const int kRandomFieldNumber = 9;
  private:
  const ::es_proto::IERandom& _internal_random() const;
  public:
  const ::es_proto::IERandom& random() const;
  ::es_proto::IERandom* release_random();
  ::es_proto::IERandom* mutable_random();
  void set_allocated_random(::es_proto::IERandom* random);

  void clear_op();
  OpCase op_case() const;
  // @@protoc_insertion_point(class_scope:es_proto.InferenceEvent)
 private:
  void set_has_init();
  void set_has_close_readers();
  void set_has_load_weight();
  void set_has_load_data_matrix();
  void set_has_load_mask();
  void set_has_load_freqs_cis();
  void set_has_execute();
  void set_has_build_next();
  void set_has_random();

  inline bool has_op() const;
  inline void clear_has_op();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union OpUnion {
    OpUnion() {}
    ::es_proto::IEInit* init_;
    ::es_proto::IECloseReaders* close_readers_;
    ::es_proto::IELoadWeight* load_weight_;
    ::es_proto::IELoadDataMatrix* load_data_matrix_;
    ::es_proto::IELoadMask* load_mask_;
    ::es_proto::IELoadFreqsCis* load_freqs_cis_;
    ::es_proto::IEExecute* execute_;
    ::es_proto::IEBuildNext* build_next_;
    ::es_proto::IERandom* random_;
  } op_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InferenceEvents : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:es_proto.InferenceEvents) */ {
 public:
  InferenceEvents();
  virtual ~InferenceEvents();

  InferenceEvents(const InferenceEvents& from);

  inline InferenceEvents& operator=(const InferenceEvents& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InferenceEvents(InferenceEvents&& from) noexcept
    : InferenceEvents() {
    *this = ::std::move(from);
  }

  inline InferenceEvents& operator=(InferenceEvents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InferenceEvents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InferenceEvents* internal_default_instance() {
    return reinterpret_cast<const InferenceEvents*>(
               &_InferenceEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(InferenceEvents* other);
  friend void swap(InferenceEvents& a, InferenceEvents& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InferenceEvents* New() const final {
    return CreateMaybeMessage<InferenceEvents>(NULL);
  }

  InferenceEvents* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InferenceEvents>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InferenceEvents& from);
  void MergeFrom(const InferenceEvents& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferenceEvents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .es_proto.InferenceEvent event = 1;
  int event_size() const;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::es_proto::InferenceEvent* mutable_event(int index);
  ::google::protobuf::RepeatedPtrField< ::es_proto::InferenceEvent >*
      mutable_event();
  const ::es_proto::InferenceEvent& event(int index) const;
  ::es_proto::InferenceEvent* add_event();
  const ::google::protobuf::RepeatedPtrField< ::es_proto::InferenceEvent >&
      event() const;

  // @@protoc_insertion_point(class_scope:es_proto.InferenceEvents)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::es_proto::InferenceEvent > event_;
  friend struct ::protobuf_einsummable_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EsInn

// repeated int32 idxs = 1;
inline int EsInn::idxs_size() const {
  return idxs_.size();
}
inline void EsInn::clear_idxs() {
  idxs_.Clear();
}
inline ::google::protobuf::int32 EsInn::idxs(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.EsInn.idxs)
  return idxs_.Get(index);
}
inline void EsInn::set_idxs(int index, ::google::protobuf::int32 value) {
  idxs_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.EsInn.idxs)
}
inline void EsInn::add_idxs(::google::protobuf::int32 value) {
  idxs_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.EsInn.idxs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EsInn::idxs() const {
  // @@protoc_insertion_point(field_list:es_proto.EsInn.idxs)
  return idxs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EsInn::mutable_idxs() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.EsInn.idxs)
  return &idxs_;
}

// -------------------------------------------------------------------

// Einsummable

// repeated uint64 join_shape = 1;
inline int Einsummable::join_shape_size() const {
  return join_shape_.size();
}
inline void Einsummable::clear_join_shape() {
  join_shape_.Clear();
}
inline ::google::protobuf::uint64 Einsummable::join_shape(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.Einsummable.join_shape)
  return join_shape_.Get(index);
}
inline void Einsummable::set_join_shape(int index, ::google::protobuf::uint64 value) {
  join_shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.Einsummable.join_shape)
}
inline void Einsummable::add_join_shape(::google::protobuf::uint64 value) {
  join_shape_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.Einsummable.join_shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Einsummable::join_shape() const {
  // @@protoc_insertion_point(field_list:es_proto.Einsummable.join_shape)
  return join_shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Einsummable::mutable_join_shape() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.Einsummable.join_shape)
  return &join_shape_;
}

// repeated .es_proto.EsInn inns = 2;
inline int Einsummable::inns_size() const {
  return inns_.size();
}
inline void Einsummable::clear_inns() {
  inns_.Clear();
}
inline ::es_proto::EsInn* Einsummable::mutable_inns(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.Einsummable.inns)
  return inns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::EsInn >*
Einsummable::mutable_inns() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.Einsummable.inns)
  return &inns_;
}
inline const ::es_proto::EsInn& Einsummable::inns(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.Einsummable.inns)
  return inns_.Get(index);
}
inline ::es_proto::EsInn* Einsummable::add_inns() {
  // @@protoc_insertion_point(field_add:es_proto.Einsummable.inns)
  return inns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::EsInn >&
Einsummable::inns() const {
  // @@protoc_insertion_point(field_list:es_proto.Einsummable.inns)
  return inns_;
}

// required int32 out_rank = 3;
inline bool Einsummable::has_out_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Einsummable::set_has_out_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Einsummable::clear_has_out_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Einsummable::clear_out_rank() {
  out_rank_ = 0;
  clear_has_out_rank();
}
inline ::google::protobuf::int32 Einsummable::out_rank() const {
  // @@protoc_insertion_point(field_get:es_proto.Einsummable.out_rank)
  return out_rank_;
}
inline void Einsummable::set_out_rank(::google::protobuf::int32 value) {
  set_has_out_rank();
  out_rank_ = value;
  // @@protoc_insertion_point(field_set:es_proto.Einsummable.out_rank)
}

// required string join = 4;
inline bool Einsummable::has_join() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Einsummable::set_has_join() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Einsummable::clear_has_join() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Einsummable::clear_join() {
  join_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_join();
}
inline const ::std::string& Einsummable::join() const {
  // @@protoc_insertion_point(field_get:es_proto.Einsummable.join)
  return join_.GetNoArena();
}
inline void Einsummable::set_join(const ::std::string& value) {
  set_has_join();
  join_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.Einsummable.join)
}
#if LANG_CXX11
inline void Einsummable::set_join(::std::string&& value) {
  set_has_join();
  join_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.Einsummable.join)
}
#endif
inline void Einsummable::set_join(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_join();
  join_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.Einsummable.join)
}
inline void Einsummable::set_join(const char* value, size_t size) {
  set_has_join();
  join_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.Einsummable.join)
}
inline ::std::string* Einsummable::mutable_join() {
  set_has_join();
  // @@protoc_insertion_point(field_mutable:es_proto.Einsummable.join)
  return join_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Einsummable::release_join() {
  // @@protoc_insertion_point(field_release:es_proto.Einsummable.join)
  if (!has_join()) {
    return NULL;
  }
  clear_has_join();
  return join_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Einsummable::set_allocated_join(::std::string* join) {
  if (join != NULL) {
    set_has_join();
  } else {
    clear_has_join();
  }
  join_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), join);
  // @@protoc_insertion_point(field_set_allocated:es_proto.Einsummable.join)
}

// optional string castable = 5;
inline bool Einsummable::has_castable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Einsummable::set_has_castable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Einsummable::clear_has_castable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Einsummable::clear_castable() {
  castable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_castable();
}
inline const ::std::string& Einsummable::castable() const {
  // @@protoc_insertion_point(field_get:es_proto.Einsummable.castable)
  return castable_.GetNoArena();
}
inline void Einsummable::set_castable(const ::std::string& value) {
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.Einsummable.castable)
}
#if LANG_CXX11
inline void Einsummable::set_castable(::std::string&& value) {
  set_has_castable();
  castable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.Einsummable.castable)
}
#endif
inline void Einsummable::set_castable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.Einsummable.castable)
}
inline void Einsummable::set_castable(const char* value, size_t size) {
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.Einsummable.castable)
}
inline ::std::string* Einsummable::mutable_castable() {
  set_has_castable();
  // @@protoc_insertion_point(field_mutable:es_proto.Einsummable.castable)
  return castable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Einsummable::release_castable() {
  // @@protoc_insertion_point(field_release:es_proto.Einsummable.castable)
  if (!has_castable()) {
    return NULL;
  }
  clear_has_castable();
  return castable_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Einsummable::set_allocated_castable(::std::string* castable) {
  if (castable != NULL) {
    set_has_castable();
  } else {
    clear_has_castable();
  }
  castable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), castable);
  // @@protoc_insertion_point(field_set_allocated:es_proto.Einsummable.castable)
}

// -------------------------------------------------------------------

// EinsummableList

// repeated .es_proto.Einsummable es = 1;
inline int EinsummableList::es_size() const {
  return es_.size();
}
inline void EinsummableList::clear_es() {
  es_.Clear();
}
inline ::es_proto::Einsummable* EinsummableList::mutable_es(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.EinsummableList.es)
  return es_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::Einsummable >*
EinsummableList::mutable_es() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.EinsummableList.es)
  return &es_;
}
inline const ::es_proto::Einsummable& EinsummableList::es(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.EinsummableList.es)
  return es_.Get(index);
}
inline ::es_proto::Einsummable* EinsummableList::add_es() {
  // @@protoc_insertion_point(field_add:es_proto.EinsummableList.es)
  return es_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::Einsummable >&
EinsummableList::es() const {
  // @@protoc_insertion_point(field_list:es_proto.EinsummableList.es)
  return es_;
}

// -------------------------------------------------------------------

// TouchDim

// required uint64 d_inn = 1;
inline bool TouchDim::has_d_inn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TouchDim::set_has_d_inn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TouchDim::clear_has_d_inn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TouchDim::clear_d_inn() {
  d_inn_ = GOOGLE_ULONGLONG(0);
  clear_has_d_inn();
}
inline ::google::protobuf::uint64 TouchDim::d_inn() const {
  // @@protoc_insertion_point(field_get:es_proto.TouchDim.d_inn)
  return d_inn_;
}
inline void TouchDim::set_d_inn(::google::protobuf::uint64 value) {
  set_has_d_inn();
  d_inn_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TouchDim.d_inn)
}

// required uint64 d_out = 2;
inline bool TouchDim::has_d_out() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TouchDim::set_has_d_out() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TouchDim::clear_has_d_out() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TouchDim::clear_d_out() {
  d_out_ = GOOGLE_ULONGLONG(0);
  clear_has_d_out();
}
inline ::google::protobuf::uint64 TouchDim::d_out() const {
  // @@protoc_insertion_point(field_get:es_proto.TouchDim.d_out)
  return d_out_;
}
inline void TouchDim::set_d_out(::google::protobuf::uint64 value) {
  set_has_d_out();
  d_out_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TouchDim.d_out)
}

// required uint64 offset_inn = 3;
inline bool TouchDim::has_offset_inn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TouchDim::set_has_offset_inn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TouchDim::clear_has_offset_inn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TouchDim::clear_offset_inn() {
  offset_inn_ = GOOGLE_ULONGLONG(0);
  clear_has_offset_inn();
}
inline ::google::protobuf::uint64 TouchDim::offset_inn() const {
  // @@protoc_insertion_point(field_get:es_proto.TouchDim.offset_inn)
  return offset_inn_;
}
inline void TouchDim::set_offset_inn(::google::protobuf::uint64 value) {
  set_has_offset_inn();
  offset_inn_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TouchDim.offset_inn)
}

// required uint64 offset_out = 4;
inline bool TouchDim::has_offset_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TouchDim::set_has_offset_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TouchDim::clear_has_offset_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TouchDim::clear_offset_out() {
  offset_out_ = GOOGLE_ULONGLONG(0);
  clear_has_offset_out();
}
inline ::google::protobuf::uint64 TouchDim::offset_out() const {
  // @@protoc_insertion_point(field_get:es_proto.TouchDim.offset_out)
  return offset_out_;
}
inline void TouchDim::set_offset_out(::google::protobuf::uint64 value) {
  set_has_offset_out();
  offset_out_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TouchDim.offset_out)
}

// required uint64 size = 5;
inline bool TouchDim::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TouchDim::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TouchDim::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TouchDim::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 TouchDim::size() const {
  // @@protoc_insertion_point(field_get:es_proto.TouchDim.size)
  return size_;
}
inline void TouchDim::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TouchDim.size)
}

// -------------------------------------------------------------------

// Touch

// repeated .es_proto.TouchDim selection = 1;
inline int Touch::selection_size() const {
  return selection_.size();
}
inline void Touch::clear_selection() {
  selection_.Clear();
}
inline ::es_proto::TouchDim* Touch::mutable_selection(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.Touch.selection)
  return selection_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::TouchDim >*
Touch::mutable_selection() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.Touch.selection)
  return &selection_;
}
inline const ::es_proto::TouchDim& Touch::selection(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.Touch.selection)
  return selection_.Get(index);
}
inline ::es_proto::TouchDim* Touch::add_selection() {
  // @@protoc_insertion_point(field_add:es_proto.Touch.selection)
  return selection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::TouchDim >&
Touch::selection() const {
  // @@protoc_insertion_point(field_list:es_proto.Touch.selection)
  return selection_;
}

// optional string castable = 2;
inline bool Touch::has_castable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Touch::set_has_castable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Touch::clear_has_castable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Touch::clear_castable() {
  castable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_castable();
}
inline const ::std::string& Touch::castable() const {
  // @@protoc_insertion_point(field_get:es_proto.Touch.castable)
  return castable_.GetNoArena();
}
inline void Touch::set_castable(const ::std::string& value) {
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.Touch.castable)
}
#if LANG_CXX11
inline void Touch::set_castable(::std::string&& value) {
  set_has_castable();
  castable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.Touch.castable)
}
#endif
inline void Touch::set_castable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.Touch.castable)
}
inline void Touch::set_castable(const char* value, size_t size) {
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.Touch.castable)
}
inline ::std::string* Touch::mutable_castable() {
  set_has_castable();
  // @@protoc_insertion_point(field_mutable:es_proto.Touch.castable)
  return castable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Touch::release_castable() {
  // @@protoc_insertion_point(field_release:es_proto.Touch.castable)
  if (!has_castable()) {
    return NULL;
  }
  clear_has_castable();
  return castable_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Touch::set_allocated_castable(::std::string* castable) {
  if (castable != NULL) {
    set_has_castable();
  } else {
    clear_has_castable();
  }
  castable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), castable);
  // @@protoc_insertion_point(field_set_allocated:es_proto.Touch.castable)
}

// required string dtype = 3;
inline bool Touch::has_dtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Touch::set_has_dtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Touch::clear_has_dtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Touch::clear_dtype() {
  dtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dtype();
}
inline const ::std::string& Touch::dtype() const {
  // @@protoc_insertion_point(field_get:es_proto.Touch.dtype)
  return dtype_.GetNoArena();
}
inline void Touch::set_dtype(const ::std::string& value) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.Touch.dtype)
}
#if LANG_CXX11
inline void Touch::set_dtype(::std::string&& value) {
  set_has_dtype();
  dtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.Touch.dtype)
}
#endif
inline void Touch::set_dtype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.Touch.dtype)
}
inline void Touch::set_dtype(const char* value, size_t size) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.Touch.dtype)
}
inline ::std::string* Touch::mutable_dtype() {
  set_has_dtype();
  // @@protoc_insertion_point(field_mutable:es_proto.Touch.dtype)
  return dtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Touch::release_dtype() {
  // @@protoc_insertion_point(field_release:es_proto.Touch.dtype)
  if (!has_dtype()) {
    return NULL;
  }
  clear_has_dtype();
  return dtype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Touch::set_allocated_dtype(::std::string* dtype) {
  if (dtype != NULL) {
    set_has_dtype();
  } else {
    clear_has_dtype();
  }
  dtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dtype);
  // @@protoc_insertion_point(field_set_allocated:es_proto.Touch.dtype)
}

// -------------------------------------------------------------------

// Fill

// required string value = 1;
inline bool Fill::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fill::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fill::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fill::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Fill::value() const {
  // @@protoc_insertion_point(field_get:es_proto.Fill.value)
  return value_.GetNoArena();
}
inline void Fill::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.Fill.value)
}
#if LANG_CXX11
inline void Fill::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.Fill.value)
}
#endif
inline void Fill::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.Fill.value)
}
inline void Fill::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.Fill.value)
}
inline ::std::string* Fill::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:es_proto.Fill.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fill::release_value() {
  // @@protoc_insertion_point(field_release:es_proto.Fill.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fill::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:es_proto.Fill.value)
}

// repeated uint64 shape = 2;
inline int Fill::shape_size() const {
  return shape_.size();
}
inline void Fill::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::uint64 Fill::shape(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.Fill.shape)
  return shape_.Get(index);
}
inline void Fill::set_shape(int index, ::google::protobuf::uint64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.Fill.shape)
}
inline void Fill::add_shape(::google::protobuf::uint64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.Fill.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Fill::shape() const {
  // @@protoc_insertion_point(field_list:es_proto.Fill.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Fill::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.Fill.shape)
  return &shape_;
}

// -------------------------------------------------------------------

// TGInput

// required int32 loc = 1;
inline bool TGInput::has_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGInput::set_has_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGInput::clear_has_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGInput::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 TGInput::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.TGInput.loc)
  return loc_;
}
inline void TGInput::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGInput.loc)
}

// required uint64 size = 2;
inline bool TGInput::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGInput::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGInput::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGInput::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 TGInput::size() const {
  // @@protoc_insertion_point(field_get:es_proto.TGInput.size)
  return size_;
}
inline void TGInput::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGInput.size)
}

// -------------------------------------------------------------------

// TGApply

// required int32 loc = 1;
inline bool TGApply::has_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGApply::set_has_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGApply::clear_has_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGApply::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 TGApply::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.TGApply.loc)
  return loc_;
}
inline void TGApply::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGApply.loc)
}

// repeated int32 inns = 2;
inline int TGApply::inns_size() const {
  return inns_.size();
}
inline void TGApply::clear_inns() {
  inns_.Clear();
}
inline ::google::protobuf::int32 TGApply::inns(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.TGApply.inns)
  return inns_.Get(index);
}
inline void TGApply::set_inns(int index, ::google::protobuf::int32 value) {
  inns_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.TGApply.inns)
}
inline void TGApply::add_inns(::google::protobuf::int32 value) {
  inns_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.TGApply.inns)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TGApply::inns() const {
  // @@protoc_insertion_point(field_list:es_proto.TGApply.inns)
  return inns_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TGApply::mutable_inns() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.TGApply.inns)
  return &inns_;
}

// required .es_proto.Einsummable einsummable = 3;
inline bool TGApply::has_einsummable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGApply::set_has_einsummable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGApply::clear_has_einsummable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGApply::clear_einsummable() {
  if (einsummable_ != NULL) einsummable_->Clear();
  clear_has_einsummable();
}
inline const ::es_proto::Einsummable& TGApply::_internal_einsummable() const {
  return *einsummable_;
}
inline const ::es_proto::Einsummable& TGApply::einsummable() const {
  const ::es_proto::Einsummable* p = einsummable_;
  // @@protoc_insertion_point(field_get:es_proto.TGApply.einsummable)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Einsummable*>(
      &::es_proto::_Einsummable_default_instance_);
}
inline ::es_proto::Einsummable* TGApply::release_einsummable() {
  // @@protoc_insertion_point(field_release:es_proto.TGApply.einsummable)
  clear_has_einsummable();
  ::es_proto::Einsummable* temp = einsummable_;
  einsummable_ = NULL;
  return temp;
}
inline ::es_proto::Einsummable* TGApply::mutable_einsummable() {
  set_has_einsummable();
  if (einsummable_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Einsummable>(GetArenaNoVirtual());
    einsummable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.TGApply.einsummable)
  return einsummable_;
}
inline void TGApply::set_allocated_einsummable(::es_proto::Einsummable* einsummable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete einsummable_;
  }
  if (einsummable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      einsummable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, einsummable, submessage_arena);
    }
    set_has_einsummable();
  } else {
    clear_has_einsummable();
  }
  einsummable_ = einsummable;
  // @@protoc_insertion_point(field_set_allocated:es_proto.TGApply.einsummable)
}

// -------------------------------------------------------------------

// TGMove

// required int32 src = 1;
inline bool TGMove::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGMove::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGMove::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGMove::clear_src() {
  src_ = 0;
  clear_has_src();
}
inline ::google::protobuf::int32 TGMove::src() const {
  // @@protoc_insertion_point(field_get:es_proto.TGMove.src)
  return src_;
}
inline void TGMove::set_src(::google::protobuf::int32 value) {
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGMove.src)
}

// required int32 dst = 2;
inline bool TGMove::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGMove::set_has_dst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGMove::clear_has_dst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGMove::clear_dst() {
  dst_ = 0;
  clear_has_dst();
}
inline ::google::protobuf::int32 TGMove::dst() const {
  // @@protoc_insertion_point(field_get:es_proto.TGMove.dst)
  return dst_;
}
inline void TGMove::set_dst(::google::protobuf::int32 value) {
  set_has_dst();
  dst_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGMove.dst)
}

// required int32 inn = 3;
inline bool TGMove::has_inn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TGMove::set_has_inn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TGMove::clear_has_inn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TGMove::clear_inn() {
  inn_ = 0;
  clear_has_inn();
}
inline ::google::protobuf::int32 TGMove::inn() const {
  // @@protoc_insertion_point(field_get:es_proto.TGMove.inn)
  return inn_;
}
inline void TGMove::set_inn(::google::protobuf::int32 value) {
  set_has_inn();
  inn_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGMove.inn)
}

// required uint64 size = 4;
inline bool TGMove::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TGMove::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TGMove::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TGMove::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 TGMove::size() const {
  // @@protoc_insertion_point(field_get:es_proto.TGMove.size)
  return size_;
}
inline void TGMove::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGMove.size)
}

// -------------------------------------------------------------------

// TGConstant

// required int32 loc = 1;
inline bool TGConstant::has_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGConstant::set_has_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGConstant::clear_has_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGConstant::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 TGConstant::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.TGConstant.loc)
  return loc_;
}
inline void TGConstant::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGConstant.loc)
}

// required .es_proto.Fill fill = 2;
inline bool TGConstant::has_fill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGConstant::set_has_fill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGConstant::clear_has_fill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGConstant::clear_fill() {
  if (fill_ != NULL) fill_->Clear();
  clear_has_fill();
}
inline const ::es_proto::Fill& TGConstant::_internal_fill() const {
  return *fill_;
}
inline const ::es_proto::Fill& TGConstant::fill() const {
  const ::es_proto::Fill* p = fill_;
  // @@protoc_insertion_point(field_get:es_proto.TGConstant.fill)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Fill*>(
      &::es_proto::_Fill_default_instance_);
}
inline ::es_proto::Fill* TGConstant::release_fill() {
  // @@protoc_insertion_point(field_release:es_proto.TGConstant.fill)
  clear_has_fill();
  ::es_proto::Fill* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline ::es_proto::Fill* TGConstant::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Fill>(GetArenaNoVirtual());
    fill_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.TGConstant.fill)
  return fill_;
}
inline void TGConstant::set_allocated_fill(::es_proto::Fill* fill) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fill_;
  }
  if (fill) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fill = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    set_has_fill();
  } else {
    clear_has_fill();
  }
  fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:es_proto.TGConstant.fill)
}

// -------------------------------------------------------------------

// InnRegionDim

// required uint64 dim = 1;
inline bool InnRegionDim::has_dim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnRegionDim::set_has_dim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnRegionDim::clear_has_dim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnRegionDim::clear_dim() {
  dim_ = GOOGLE_ULONGLONG(0);
  clear_has_dim();
}
inline ::google::protobuf::uint64 InnRegionDim::dim() const {
  // @@protoc_insertion_point(field_get:es_proto.InnRegionDim.dim)
  return dim_;
}
inline void InnRegionDim::set_dim(::google::protobuf::uint64 value) {
  set_has_dim();
  dim_ = value;
  // @@protoc_insertion_point(field_set:es_proto.InnRegionDim.dim)
}

// required uint64 offset = 2;
inline bool InnRegionDim::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnRegionDim::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnRegionDim::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnRegionDim::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 InnRegionDim::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.InnRegionDim.offset)
  return offset_;
}
inline void InnRegionDim::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.InnRegionDim.offset)
}

// -------------------------------------------------------------------

// OutRegionDim

// required uint64 offset = 1;
inline bool OutRegionDim::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutRegionDim::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutRegionDim::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutRegionDim::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 OutRegionDim::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.OutRegionDim.offset)
  return offset_;
}
inline void OutRegionDim::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.OutRegionDim.offset)
}

// required uint64 size = 2;
inline bool OutRegionDim::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutRegionDim::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutRegionDim::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutRegionDim::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 OutRegionDim::size() const {
  // @@protoc_insertion_point(field_get:es_proto.OutRegionDim.size)
  return size_;
}
inline void OutRegionDim::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.OutRegionDim.size)
}

// -------------------------------------------------------------------

// TGPartialInn

// required int32 id = 1;
inline bool TGPartialInn::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGPartialInn::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGPartialInn::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGPartialInn::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TGPartialInn::id() const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialInn.id)
  return id_;
}
inline void TGPartialInn::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGPartialInn.id)
}

// required bool consumable = 2;
inline bool TGPartialInn::has_consumable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGPartialInn::set_has_consumable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGPartialInn::clear_has_consumable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGPartialInn::clear_consumable() {
  consumable_ = false;
  clear_has_consumable();
}
inline bool TGPartialInn::consumable() const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialInn.consumable)
  return consumable_;
}
inline void TGPartialInn::set_consumable(bool value) {
  set_has_consumable();
  consumable_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGPartialInn.consumable)
}

// repeated .es_proto.InnRegionDim region = 3;
inline int TGPartialInn::region_size() const {
  return region_.size();
}
inline void TGPartialInn::clear_region() {
  region_.Clear();
}
inline ::es_proto::InnRegionDim* TGPartialInn::mutable_region(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.TGPartialInn.region)
  return region_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::InnRegionDim >*
TGPartialInn::mutable_region() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.TGPartialInn.region)
  return &region_;
}
inline const ::es_proto::InnRegionDim& TGPartialInn::region(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialInn.region)
  return region_.Get(index);
}
inline ::es_proto::InnRegionDim* TGPartialInn::add_region() {
  // @@protoc_insertion_point(field_add:es_proto.TGPartialInn.region)
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::InnRegionDim >&
TGPartialInn::region() const {
  // @@protoc_insertion_point(field_list:es_proto.TGPartialInn.region)
  return region_;
}

// -------------------------------------------------------------------

// TGPartialUnit

// optional string castable = 1;
inline bool TGPartialUnit::has_castable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGPartialUnit::set_has_castable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGPartialUnit::clear_has_castable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGPartialUnit::clear_castable() {
  castable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_castable();
}
inline const ::std::string& TGPartialUnit::castable() const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialUnit.castable)
  return castable_.GetNoArena();
}
inline void TGPartialUnit::set_castable(const ::std::string& value) {
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.TGPartialUnit.castable)
}
#if LANG_CXX11
inline void TGPartialUnit::set_castable(::std::string&& value) {
  set_has_castable();
  castable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.TGPartialUnit.castable)
}
#endif
inline void TGPartialUnit::set_castable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.TGPartialUnit.castable)
}
inline void TGPartialUnit::set_castable(const char* value, size_t size) {
  set_has_castable();
  castable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.TGPartialUnit.castable)
}
inline ::std::string* TGPartialUnit::mutable_castable() {
  set_has_castable();
  // @@protoc_insertion_point(field_mutable:es_proto.TGPartialUnit.castable)
  return castable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGPartialUnit::release_castable() {
  // @@protoc_insertion_point(field_release:es_proto.TGPartialUnit.castable)
  if (!has_castable()) {
    return NULL;
  }
  clear_has_castable();
  return castable_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGPartialUnit::set_allocated_castable(::std::string* castable) {
  if (castable != NULL) {
    set_has_castable();
  } else {
    clear_has_castable();
  }
  castable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), castable);
  // @@protoc_insertion_point(field_set_allocated:es_proto.TGPartialUnit.castable)
}

// repeated .es_proto.OutRegionDim out_region = 2;
inline int TGPartialUnit::out_region_size() const {
  return out_region_.size();
}
inline void TGPartialUnit::clear_out_region() {
  out_region_.Clear();
}
inline ::es_proto::OutRegionDim* TGPartialUnit::mutable_out_region(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.TGPartialUnit.out_region)
  return out_region_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::OutRegionDim >*
TGPartialUnit::mutable_out_region() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.TGPartialUnit.out_region)
  return &out_region_;
}
inline const ::es_proto::OutRegionDim& TGPartialUnit::out_region(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialUnit.out_region)
  return out_region_.Get(index);
}
inline ::es_proto::OutRegionDim* TGPartialUnit::add_out_region() {
  // @@protoc_insertion_point(field_add:es_proto.TGPartialUnit.out_region)
  return out_region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::OutRegionDim >&
TGPartialUnit::out_region() const {
  // @@protoc_insertion_point(field_list:es_proto.TGPartialUnit.out_region)
  return out_region_;
}

// repeated .es_proto.TGPartialInn inputs = 3;
inline int TGPartialUnit::inputs_size() const {
  return inputs_.size();
}
inline void TGPartialUnit::clear_inputs() {
  inputs_.Clear();
}
inline ::es_proto::TGPartialInn* TGPartialUnit::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.TGPartialUnit.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialInn >*
TGPartialUnit::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.TGPartialUnit.inputs)
  return &inputs_;
}
inline const ::es_proto::TGPartialInn& TGPartialUnit::inputs(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialUnit.inputs)
  return inputs_.Get(index);
}
inline ::es_proto::TGPartialInn* TGPartialUnit::add_inputs() {
  // @@protoc_insertion_point(field_add:es_proto.TGPartialUnit.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialInn >&
TGPartialUnit::inputs() const {
  // @@protoc_insertion_point(field_list:es_proto.TGPartialUnit.inputs)
  return inputs_;
}

// -------------------------------------------------------------------

// TGPartialize

// required int32 loc = 1;
inline bool TGPartialize::has_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGPartialize::set_has_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGPartialize::clear_has_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGPartialize::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 TGPartialize::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialize.loc)
  return loc_;
}
inline void TGPartialize::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TGPartialize.loc)
}

// required string dtype = 2;
inline bool TGPartialize::has_dtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGPartialize::set_has_dtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGPartialize::clear_has_dtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGPartialize::clear_dtype() {
  dtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dtype();
}
inline const ::std::string& TGPartialize::dtype() const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialize.dtype)
  return dtype_.GetNoArena();
}
inline void TGPartialize::set_dtype(const ::std::string& value) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.TGPartialize.dtype)
}
#if LANG_CXX11
inline void TGPartialize::set_dtype(::std::string&& value) {
  set_has_dtype();
  dtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.TGPartialize.dtype)
}
#endif
inline void TGPartialize::set_dtype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.TGPartialize.dtype)
}
inline void TGPartialize::set_dtype(const char* value, size_t size) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.TGPartialize.dtype)
}
inline ::std::string* TGPartialize::mutable_dtype() {
  set_has_dtype();
  // @@protoc_insertion_point(field_mutable:es_proto.TGPartialize.dtype)
  return dtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TGPartialize::release_dtype() {
  // @@protoc_insertion_point(field_release:es_proto.TGPartialize.dtype)
  if (!has_dtype()) {
    return NULL;
  }
  clear_has_dtype();
  return dtype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TGPartialize::set_allocated_dtype(::std::string* dtype) {
  if (dtype != NULL) {
    set_has_dtype();
  } else {
    clear_has_dtype();
  }
  dtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dtype);
  // @@protoc_insertion_point(field_set_allocated:es_proto.TGPartialize.dtype)
}

// repeated uint64 write_shape = 3;
inline int TGPartialize::write_shape_size() const {
  return write_shape_.size();
}
inline void TGPartialize::clear_write_shape() {
  write_shape_.Clear();
}
inline ::google::protobuf::uint64 TGPartialize::write_shape(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialize.write_shape)
  return write_shape_.Get(index);
}
inline void TGPartialize::set_write_shape(int index, ::google::protobuf::uint64 value) {
  write_shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.TGPartialize.write_shape)
}
inline void TGPartialize::add_write_shape(::google::protobuf::uint64 value) {
  write_shape_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.TGPartialize.write_shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
TGPartialize::write_shape() const {
  // @@protoc_insertion_point(field_list:es_proto.TGPartialize.write_shape)
  return write_shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
TGPartialize::mutable_write_shape() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.TGPartialize.write_shape)
  return &write_shape_;
}

// repeated .es_proto.TGPartialUnit units = 4;
inline int TGPartialize::units_size() const {
  return units_.size();
}
inline void TGPartialize::clear_units() {
  units_.Clear();
}
inline ::es_proto::TGPartialUnit* TGPartialize::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.TGPartialize.units)
  return units_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialUnit >*
TGPartialize::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.TGPartialize.units)
  return &units_;
}
inline const ::es_proto::TGPartialUnit& TGPartialize::units(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.TGPartialize.units)
  return units_.Get(index);
}
inline ::es_proto::TGPartialUnit* TGPartialize::add_units() {
  // @@protoc_insertion_point(field_add:es_proto.TGPartialize.units)
  return units_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::TGPartialUnit >&
TGPartialize::units() const {
  // @@protoc_insertion_point(field_list:es_proto.TGPartialize.units)
  return units_;
}

// -------------------------------------------------------------------

// TaskGraphNode

// optional .es_proto.TGInput input = 1;
inline bool TaskGraphNode::has_input() const {
  return node_case() == kInput;
}
inline void TaskGraphNode::set_has_input() {
  _oneof_case_[0] = kInput;
}
inline void TaskGraphNode::clear_input() {
  if (has_input()) {
    delete node_.input_;
    clear_has_node();
  }
}
inline const ::es_proto::TGInput& TaskGraphNode::_internal_input() const {
  return *node_.input_;
}
inline ::es_proto::TGInput* TaskGraphNode::release_input() {
  // @@protoc_insertion_point(field_release:es_proto.TaskGraphNode.input)
  if (has_input()) {
    clear_has_node();
      ::es_proto::TGInput* temp = node_.input_;
    node_.input_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::TGInput& TaskGraphNode::input() const {
  // @@protoc_insertion_point(field_get:es_proto.TaskGraphNode.input)
  return has_input()
      ? *node_.input_
      : *reinterpret_cast< ::es_proto::TGInput*>(&::es_proto::_TGInput_default_instance_);
}
inline ::es_proto::TGInput* TaskGraphNode::mutable_input() {
  if (!has_input()) {
    clear_node();
    set_has_input();
    node_.input_ = CreateMaybeMessage< ::es_proto::TGInput >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.TaskGraphNode.input)
  return node_.input_;
}

// optional .es_proto.TGApply apply = 2;
inline bool TaskGraphNode::has_apply() const {
  return node_case() == kApply;
}
inline void TaskGraphNode::set_has_apply() {
  _oneof_case_[0] = kApply;
}
inline void TaskGraphNode::clear_apply() {
  if (has_apply()) {
    delete node_.apply_;
    clear_has_node();
  }
}
inline const ::es_proto::TGApply& TaskGraphNode::_internal_apply() const {
  return *node_.apply_;
}
inline ::es_proto::TGApply* TaskGraphNode::release_apply() {
  // @@protoc_insertion_point(field_release:es_proto.TaskGraphNode.apply)
  if (has_apply()) {
    clear_has_node();
      ::es_proto::TGApply* temp = node_.apply_;
    node_.apply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::TGApply& TaskGraphNode::apply() const {
  // @@protoc_insertion_point(field_get:es_proto.TaskGraphNode.apply)
  return has_apply()
      ? *node_.apply_
      : *reinterpret_cast< ::es_proto::TGApply*>(&::es_proto::_TGApply_default_instance_);
}
inline ::es_proto::TGApply* TaskGraphNode::mutable_apply() {
  if (!has_apply()) {
    clear_node();
    set_has_apply();
    node_.apply_ = CreateMaybeMessage< ::es_proto::TGApply >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.TaskGraphNode.apply)
  return node_.apply_;
}

// optional .es_proto.TGMove move = 3;
inline bool TaskGraphNode::has_move() const {
  return node_case() == kMove;
}
inline void TaskGraphNode::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void TaskGraphNode::clear_move() {
  if (has_move()) {
    delete node_.move_;
    clear_has_node();
  }
}
inline const ::es_proto::TGMove& TaskGraphNode::_internal_move() const {
  return *node_.move_;
}
inline ::es_proto::TGMove* TaskGraphNode::release_move() {
  // @@protoc_insertion_point(field_release:es_proto.TaskGraphNode.move)
  if (has_move()) {
    clear_has_node();
      ::es_proto::TGMove* temp = node_.move_;
    node_.move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::TGMove& TaskGraphNode::move() const {
  // @@protoc_insertion_point(field_get:es_proto.TaskGraphNode.move)
  return has_move()
      ? *node_.move_
      : *reinterpret_cast< ::es_proto::TGMove*>(&::es_proto::_TGMove_default_instance_);
}
inline ::es_proto::TGMove* TaskGraphNode::mutable_move() {
  if (!has_move()) {
    clear_node();
    set_has_move();
    node_.move_ = CreateMaybeMessage< ::es_proto::TGMove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.TaskGraphNode.move)
  return node_.move_;
}

// optional .es_proto.TGConstant constant = 4;
inline bool TaskGraphNode::has_constant() const {
  return node_case() == kConstant;
}
inline void TaskGraphNode::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void TaskGraphNode::clear_constant() {
  if (has_constant()) {
    delete node_.constant_;
    clear_has_node();
  }
}
inline const ::es_proto::TGConstant& TaskGraphNode::_internal_constant() const {
  return *node_.constant_;
}
inline ::es_proto::TGConstant* TaskGraphNode::release_constant() {
  // @@protoc_insertion_point(field_release:es_proto.TaskGraphNode.constant)
  if (has_constant()) {
    clear_has_node();
      ::es_proto::TGConstant* temp = node_.constant_;
    node_.constant_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::TGConstant& TaskGraphNode::constant() const {
  // @@protoc_insertion_point(field_get:es_proto.TaskGraphNode.constant)
  return has_constant()
      ? *node_.constant_
      : *reinterpret_cast< ::es_proto::TGConstant*>(&::es_proto::_TGConstant_default_instance_);
}
inline ::es_proto::TGConstant* TaskGraphNode::mutable_constant() {
  if (!has_constant()) {
    clear_node();
    set_has_constant();
    node_.constant_ = CreateMaybeMessage< ::es_proto::TGConstant >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.TaskGraphNode.constant)
  return node_.constant_;
}

// optional .es_proto.TGPartialize partialize = 5;
inline bool TaskGraphNode::has_partialize() const {
  return node_case() == kPartialize;
}
inline void TaskGraphNode::set_has_partialize() {
  _oneof_case_[0] = kPartialize;
}
inline void TaskGraphNode::clear_partialize() {
  if (has_partialize()) {
    delete node_.partialize_;
    clear_has_node();
  }
}
inline const ::es_proto::TGPartialize& TaskGraphNode::_internal_partialize() const {
  return *node_.partialize_;
}
inline ::es_proto::TGPartialize* TaskGraphNode::release_partialize() {
  // @@protoc_insertion_point(field_release:es_proto.TaskGraphNode.partialize)
  if (has_partialize()) {
    clear_has_node();
      ::es_proto::TGPartialize* temp = node_.partialize_;
    node_.partialize_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::TGPartialize& TaskGraphNode::partialize() const {
  // @@protoc_insertion_point(field_get:es_proto.TaskGraphNode.partialize)
  return has_partialize()
      ? *node_.partialize_
      : *reinterpret_cast< ::es_proto::TGPartialize*>(&::es_proto::_TGPartialize_default_instance_);
}
inline ::es_proto::TGPartialize* TaskGraphNode::mutable_partialize() {
  if (!has_partialize()) {
    clear_node();
    set_has_partialize();
    node_.partialize_ = CreateMaybeMessage< ::es_proto::TGPartialize >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.TaskGraphNode.partialize)
  return node_.partialize_;
}

// required bool is_save = 6;
inline bool TaskGraphNode::has_is_save() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskGraphNode::set_has_is_save() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskGraphNode::clear_has_is_save() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskGraphNode::clear_is_save() {
  is_save_ = false;
  clear_has_is_save();
}
inline bool TaskGraphNode::is_save() const {
  // @@protoc_insertion_point(field_get:es_proto.TaskGraphNode.is_save)
  return is_save_;
}
inline void TaskGraphNode::set_is_save(bool value) {
  set_has_is_save();
  is_save_ = value;
  // @@protoc_insertion_point(field_set:es_proto.TaskGraphNode.is_save)
}

inline bool TaskGraphNode::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void TaskGraphNode::clear_has_node() {
  _oneof_case_[0] = NODE_NOT_SET;
}
inline TaskGraphNode::NodeCase TaskGraphNode::node_case() const {
  return TaskGraphNode::NodeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskGraph

// repeated .es_proto.TaskGraphNode nodes = 1;
inline int TaskGraph::nodes_size() const {
  return nodes_.size();
}
inline void TaskGraph::clear_nodes() {
  nodes_.Clear();
}
inline ::es_proto::TaskGraphNode* TaskGraph::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.TaskGraph.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::TaskGraphNode >*
TaskGraph::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.TaskGraph.nodes)
  return &nodes_;
}
inline const ::es_proto::TaskGraphNode& TaskGraph::nodes(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.TaskGraph.nodes)
  return nodes_.Get(index);
}
inline ::es_proto::TaskGraphNode* TaskGraph::add_nodes() {
  // @@protoc_insertion_point(field_add:es_proto.TaskGraph.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::TaskGraphNode >&
TaskGraph::nodes() const {
  // @@protoc_insertion_point(field_list:es_proto.TaskGraph.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// Partdim

// repeated uint64 spans = 1;
inline int Partdim::spans_size() const {
  return spans_.size();
}
inline void Partdim::clear_spans() {
  spans_.Clear();
}
inline ::google::protobuf::uint64 Partdim::spans(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.Partdim.spans)
  return spans_.Get(index);
}
inline void Partdim::set_spans(int index, ::google::protobuf::uint64 value) {
  spans_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.Partdim.spans)
}
inline void Partdim::add_spans(::google::protobuf::uint64 value) {
  spans_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.Partdim.spans)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Partdim::spans() const {
  // @@protoc_insertion_point(field_list:es_proto.Partdim.spans)
  return spans_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Partdim::mutable_spans() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.Partdim.spans)
  return &spans_;
}

// -------------------------------------------------------------------

// Partition

// repeated .es_proto.Partdim partdims = 1;
inline int Partition::partdims_size() const {
  return partdims_.size();
}
inline void Partition::clear_partdims() {
  partdims_.Clear();
}
inline ::es_proto::Partdim* Partition::mutable_partdims(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.Partition.partdims)
  return partdims_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::Partdim >*
Partition::mutable_partdims() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.Partition.partdims)
  return &partdims_;
}
inline const ::es_proto::Partdim& Partition::partdims(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.Partition.partdims)
  return partdims_.Get(index);
}
inline ::es_proto::Partdim* Partition::add_partdims() {
  // @@protoc_insertion_point(field_add:es_proto.Partition.partdims)
  return partdims_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::Partdim >&
Partition::partdims() const {
  // @@protoc_insertion_point(field_list:es_proto.Partition.partdims)
  return partdims_;
}

// -------------------------------------------------------------------

// Placement

// required .es_proto.Partition partition = 1;
inline bool Placement::has_partition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Placement::set_has_partition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Placement::clear_has_partition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Placement::clear_partition() {
  if (partition_ != NULL) partition_->Clear();
  clear_has_partition();
}
inline const ::es_proto::Partition& Placement::_internal_partition() const {
  return *partition_;
}
inline const ::es_proto::Partition& Placement::partition() const {
  const ::es_proto::Partition* p = partition_;
  // @@protoc_insertion_point(field_get:es_proto.Placement.partition)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Partition*>(
      &::es_proto::_Partition_default_instance_);
}
inline ::es_proto::Partition* Placement::release_partition() {
  // @@protoc_insertion_point(field_release:es_proto.Placement.partition)
  clear_has_partition();
  ::es_proto::Partition* temp = partition_;
  partition_ = NULL;
  return temp;
}
inline ::es_proto::Partition* Placement::mutable_partition() {
  set_has_partition();
  if (partition_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Partition>(GetArenaNoVirtual());
    partition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.Placement.partition)
  return partition_;
}
inline void Placement::set_allocated_partition(::es_proto::Partition* partition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete partition_;
  }
  if (partition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      partition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, partition, submessage_arena);
    }
    set_has_partition();
  } else {
    clear_has_partition();
  }
  partition_ = partition;
  // @@protoc_insertion_point(field_set_allocated:es_proto.Placement.partition)
}

// repeated int32 locations = 2;
inline int Placement::locations_size() const {
  return locations_.size();
}
inline void Placement::clear_locations() {
  locations_.Clear();
}
inline ::google::protobuf::int32 Placement::locations(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.Placement.locations)
  return locations_.Get(index);
}
inline void Placement::set_locations(int index, ::google::protobuf::int32 value) {
  locations_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.Placement.locations)
}
inline void Placement::add_locations(::google::protobuf::int32 value) {
  locations_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.Placement.locations)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Placement::locations() const {
  // @@protoc_insertion_point(field_list:es_proto.Placement.locations)
  return locations_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Placement::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.Placement.locations)
  return &locations_;
}

// -------------------------------------------------------------------

// Relation

// required string dtype = 1;
inline bool Relation::has_dtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Relation::set_has_dtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Relation::clear_has_dtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Relation::clear_dtype() {
  dtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dtype();
}
inline const ::std::string& Relation::dtype() const {
  // @@protoc_insertion_point(field_get:es_proto.Relation.dtype)
  return dtype_.GetNoArena();
}
inline void Relation::set_dtype(const ::std::string& value) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.Relation.dtype)
}
#if LANG_CXX11
inline void Relation::set_dtype(::std::string&& value) {
  set_has_dtype();
  dtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.Relation.dtype)
}
#endif
inline void Relation::set_dtype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.Relation.dtype)
}
inline void Relation::set_dtype(const char* value, size_t size) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.Relation.dtype)
}
inline ::std::string* Relation::mutable_dtype() {
  set_has_dtype();
  // @@protoc_insertion_point(field_mutable:es_proto.Relation.dtype)
  return dtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Relation::release_dtype() {
  // @@protoc_insertion_point(field_release:es_proto.Relation.dtype)
  if (!has_dtype()) {
    return NULL;
  }
  clear_has_dtype();
  return dtype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_allocated_dtype(::std::string* dtype) {
  if (dtype != NULL) {
    set_has_dtype();
  } else {
    clear_has_dtype();
  }
  dtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dtype);
  // @@protoc_insertion_point(field_set_allocated:es_proto.Relation.dtype)
}

// required .es_proto.Placement placement = 2;
inline bool Relation::has_placement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Relation::set_has_placement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Relation::clear_has_placement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Relation::clear_placement() {
  if (placement_ != NULL) placement_->Clear();
  clear_has_placement();
}
inline const ::es_proto::Placement& Relation::_internal_placement() const {
  return *placement_;
}
inline const ::es_proto::Placement& Relation::placement() const {
  const ::es_proto::Placement* p = placement_;
  // @@protoc_insertion_point(field_get:es_proto.Relation.placement)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Placement*>(
      &::es_proto::_Placement_default_instance_);
}
inline ::es_proto::Placement* Relation::release_placement() {
  // @@protoc_insertion_point(field_release:es_proto.Relation.placement)
  clear_has_placement();
  ::es_proto::Placement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline ::es_proto::Placement* Relation::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Placement>(GetArenaNoVirtual());
    placement_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.Relation.placement)
  return placement_;
}
inline void Relation::set_allocated_placement(::es_proto::Placement* placement) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete placement_;
  }
  if (placement) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      placement = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, placement, submessage_arena);
    }
    set_has_placement();
  } else {
    clear_has_placement();
  }
  placement_ = placement;
  // @@protoc_insertion_point(field_set_allocated:es_proto.Relation.placement)
}

// repeated int32 tids = 4;
inline int Relation::tids_size() const {
  return tids_.size();
}
inline void Relation::clear_tids() {
  tids_.Clear();
}
inline ::google::protobuf::int32 Relation::tids(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.Relation.tids)
  return tids_.Get(index);
}
inline void Relation::set_tids(int index, ::google::protobuf::int32 value) {
  tids_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.Relation.tids)
}
inline void Relation::add_tids(::google::protobuf::int32 value) {
  tids_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.Relation.tids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Relation::tids() const {
  // @@protoc_insertion_point(field_list:es_proto.Relation.tids)
  return tids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Relation::mutable_tids() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.Relation.tids)
  return &tids_;
}

// -------------------------------------------------------------------

// RemapRelations

// repeated .es_proto.Relation srcs = 1;
inline int RemapRelations::srcs_size() const {
  return srcs_.size();
}
inline void RemapRelations::clear_srcs() {
  srcs_.Clear();
}
inline ::es_proto::Relation* RemapRelations::mutable_srcs(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.RemapRelations.srcs)
  return srcs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::Relation >*
RemapRelations::mutable_srcs() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.RemapRelations.srcs)
  return &srcs_;
}
inline const ::es_proto::Relation& RemapRelations::srcs(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.RemapRelations.srcs)
  return srcs_.Get(index);
}
inline ::es_proto::Relation* RemapRelations::add_srcs() {
  // @@protoc_insertion_point(field_add:es_proto.RemapRelations.srcs)
  return srcs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::Relation >&
RemapRelations::srcs() const {
  // @@protoc_insertion_point(field_list:es_proto.RemapRelations.srcs)
  return srcs_;
}

// repeated .es_proto.Relation dsts = 2;
inline int RemapRelations::dsts_size() const {
  return dsts_.size();
}
inline void RemapRelations::clear_dsts() {
  dsts_.Clear();
}
inline ::es_proto::Relation* RemapRelations::mutable_dsts(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.RemapRelations.dsts)
  return dsts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::Relation >*
RemapRelations::mutable_dsts() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.RemapRelations.dsts)
  return &dsts_;
}
inline const ::es_proto::Relation& RemapRelations::dsts(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.RemapRelations.dsts)
  return dsts_.Get(index);
}
inline ::es_proto::Relation* RemapRelations::add_dsts() {
  // @@protoc_insertion_point(field_add:es_proto.RemapRelations.dsts)
  return dsts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::Relation >&
RemapRelations::dsts() const {
  // @@protoc_insertion_point(field_list:es_proto.RemapRelations.dsts)
  return dsts_;
}

// -------------------------------------------------------------------

// MGInputMem

// required int32 loc = 1;
inline bool MGInputMem::has_loc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGInputMem::set_has_loc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGInputMem::clear_has_loc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGInputMem::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MGInputMem::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGInputMem.loc)
  return loc_;
}
inline void MGInputMem::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGInputMem.loc)
}

// required uint64 offset = 2;
inline bool MGInputMem::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGInputMem::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGInputMem::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGInputMem::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MGInputMem::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGInputMem.offset)
  return offset_;
}
inline void MGInputMem::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGInputMem.offset)
}

// required uint64 size = 3;
inline bool MGInputMem::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGInputMem::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGInputMem::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGInputMem::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MGInputMem::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MGInputMem.size)
  return size_;
}
inline void MGInputMem::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGInputMem.size)
}

// -------------------------------------------------------------------

// MGInputSto

// required int32 storage_loc = 1;
inline bool MGInputSto::has_storage_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGInputSto::set_has_storage_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGInputSto::clear_has_storage_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGInputSto::clear_storage_loc() {
  storage_loc_ = 0;
  clear_has_storage_loc();
}
inline ::google::protobuf::int32 MGInputSto::storage_loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGInputSto.storage_loc)
  return storage_loc_;
}
inline void MGInputSto::set_storage_loc(::google::protobuf::int32 value) {
  set_has_storage_loc();
  storage_loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGInputSto.storage_loc)
}

// required int32 storage_id = 2;
inline bool MGInputSto::has_storage_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGInputSto::set_has_storage_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGInputSto::clear_has_storage_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGInputSto::clear_storage_id() {
  storage_id_ = 0;
  clear_has_storage_id();
}
inline ::google::protobuf::int32 MGInputSto::storage_id() const {
  // @@protoc_insertion_point(field_get:es_proto.MGInputSto.storage_id)
  return storage_id_;
}
inline void MGInputSto::set_storage_id(::google::protobuf::int32 value) {
  set_has_storage_id();
  storage_id_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGInputSto.storage_id)
}

// required uint64 size = 3;
inline bool MGInputSto::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGInputSto::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGInputSto::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGInputSto::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MGInputSto::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MGInputSto.size)
  return size_;
}
inline void MGInputSto::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGInputSto.size)
}

// -------------------------------------------------------------------

// MGConstant

// required int32 loc = 1;
inline bool MGConstant::has_loc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGConstant::set_has_loc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGConstant::clear_has_loc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGConstant::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MGConstant::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGConstant.loc)
  return loc_;
}
inline void MGConstant::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGConstant.loc)
}

// required uint64 offset = 2;
inline bool MGConstant::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGConstant::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGConstant::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGConstant::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MGConstant::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGConstant.offset)
  return offset_;
}
inline void MGConstant::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGConstant.offset)
}

// required .es_proto.Fill fill = 3;
inline bool MGConstant::has_fill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGConstant::set_has_fill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGConstant::clear_has_fill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGConstant::clear_fill() {
  if (fill_ != NULL) fill_->Clear();
  clear_has_fill();
}
inline const ::es_proto::Fill& MGConstant::_internal_fill() const {
  return *fill_;
}
inline const ::es_proto::Fill& MGConstant::fill() const {
  const ::es_proto::Fill* p = fill_;
  // @@protoc_insertion_point(field_get:es_proto.MGConstant.fill)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Fill*>(
      &::es_proto::_Fill_default_instance_);
}
inline ::es_proto::Fill* MGConstant::release_fill() {
  // @@protoc_insertion_point(field_release:es_proto.MGConstant.fill)
  clear_has_fill();
  ::es_proto::Fill* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline ::es_proto::Fill* MGConstant::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Fill>(GetArenaNoVirtual());
    fill_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MGConstant.fill)
  return fill_;
}
inline void MGConstant::set_allocated_fill(::es_proto::Fill* fill) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fill_;
  }
  if (fill) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fill = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    set_has_fill();
  } else {
    clear_has_fill();
  }
  fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:es_proto.MGConstant.fill)
}

// -------------------------------------------------------------------

// MGApply

// required int32 loc = 1;
inline bool MGApply::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGApply::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGApply::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGApply::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MGApply::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGApply.loc)
  return loc_;
}
inline void MGApply::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGApply.loc)
}

// repeated uint64 mems_offset = 2;
inline int MGApply::mems_offset_size() const {
  return mems_offset_.size();
}
inline void MGApply::clear_mems_offset() {
  mems_offset_.Clear();
}
inline ::google::protobuf::uint64 MGApply::mems_offset(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.MGApply.mems_offset)
  return mems_offset_.Get(index);
}
inline void MGApply::set_mems_offset(int index, ::google::protobuf::uint64 value) {
  mems_offset_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.MGApply.mems_offset)
}
inline void MGApply::add_mems_offset(::google::protobuf::uint64 value) {
  mems_offset_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.MGApply.mems_offset)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
MGApply::mems_offset() const {
  // @@protoc_insertion_point(field_list:es_proto.MGApply.mems_offset)
  return mems_offset_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
MGApply::mutable_mems_offset() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.MGApply.mems_offset)
  return &mems_offset_;
}

// repeated uint64 mems_size = 3;
inline int MGApply::mems_size_size() const {
  return mems_size_.size();
}
inline void MGApply::clear_mems_size() {
  mems_size_.Clear();
}
inline ::google::protobuf::uint64 MGApply::mems_size(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.MGApply.mems_size)
  return mems_size_.Get(index);
}
inline void MGApply::set_mems_size(int index, ::google::protobuf::uint64 value) {
  mems_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.MGApply.mems_size)
}
inline void MGApply::add_mems_size(::google::protobuf::uint64 value) {
  mems_size_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.MGApply.mems_size)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
MGApply::mems_size() const {
  // @@protoc_insertion_point(field_list:es_proto.MGApply.mems_size)
  return mems_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
MGApply::mutable_mems_size() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.MGApply.mems_size)
  return &mems_size_;
}

// optional .es_proto.Einsummable einsummable = 4;
inline bool MGApply::has_einsummable() const {
  return op_case() == kEinsummable;
}
inline void MGApply::set_has_einsummable() {
  _oneof_case_[0] = kEinsummable;
}
inline void MGApply::clear_einsummable() {
  if (has_einsummable()) {
    delete op_.einsummable_;
    clear_has_op();
  }
}
inline const ::es_proto::Einsummable& MGApply::_internal_einsummable() const {
  return *op_.einsummable_;
}
inline ::es_proto::Einsummable* MGApply::release_einsummable() {
  // @@protoc_insertion_point(field_release:es_proto.MGApply.einsummable)
  if (has_einsummable()) {
    clear_has_op();
      ::es_proto::Einsummable* temp = op_.einsummable_;
    op_.einsummable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::Einsummable& MGApply::einsummable() const {
  // @@protoc_insertion_point(field_get:es_proto.MGApply.einsummable)
  return has_einsummable()
      ? *op_.einsummable_
      : *reinterpret_cast< ::es_proto::Einsummable*>(&::es_proto::_Einsummable_default_instance_);
}
inline ::es_proto::Einsummable* MGApply::mutable_einsummable() {
  if (!has_einsummable()) {
    clear_op();
    set_has_einsummable();
    op_.einsummable_ = CreateMaybeMessage< ::es_proto::Einsummable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MGApply.einsummable)
  return op_.einsummable_;
}

// optional .es_proto.Touch touch = 5;
inline bool MGApply::has_touch() const {
  return op_case() == kTouch;
}
inline void MGApply::set_has_touch() {
  _oneof_case_[0] = kTouch;
}
inline void MGApply::clear_touch() {
  if (has_touch()) {
    delete op_.touch_;
    clear_has_op();
  }
}
inline const ::es_proto::Touch& MGApply::_internal_touch() const {
  return *op_.touch_;
}
inline ::es_proto::Touch* MGApply::release_touch() {
  // @@protoc_insertion_point(field_release:es_proto.MGApply.touch)
  if (has_touch()) {
    clear_has_op();
      ::es_proto::Touch* temp = op_.touch_;
    op_.touch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::Touch& MGApply::touch() const {
  // @@protoc_insertion_point(field_get:es_proto.MGApply.touch)
  return has_touch()
      ? *op_.touch_
      : *reinterpret_cast< ::es_proto::Touch*>(&::es_proto::_Touch_default_instance_);
}
inline ::es_proto::Touch* MGApply::mutable_touch() {
  if (!has_touch()) {
    clear_op();
    set_has_touch();
    op_.touch_ = CreateMaybeMessage< ::es_proto::Touch >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MGApply.touch)
  return op_.touch_;
}

// required int32 group = 6;
inline bool MGApply::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGApply::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGApply::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGApply::clear_group() {
  group_ = 0;
  clear_has_group();
}
inline ::google::protobuf::int32 MGApply::group() const {
  // @@protoc_insertion_point(field_get:es_proto.MGApply.group)
  return group_;
}
inline void MGApply::set_group(::google::protobuf::int32 value) {
  set_has_group();
  group_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGApply.group)
}

inline bool MGApply::has_op() const {
  return op_case() != OP_NOT_SET;
}
inline void MGApply::clear_has_op() {
  _oneof_case_[0] = OP_NOT_SET;
}
inline MGApply::OpCase MGApply::op_case() const {
  return MGApply::OpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MGMove

// required int32 src_loc = 1;
inline bool MGMove::has_src_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGMove::set_has_src_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGMove::clear_has_src_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGMove::clear_src_loc() {
  src_loc_ = 0;
  clear_has_src_loc();
}
inline ::google::protobuf::int32 MGMove::src_loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGMove.src_loc)
  return src_loc_;
}
inline void MGMove::set_src_loc(::google::protobuf::int32 value) {
  set_has_src_loc();
  src_loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGMove.src_loc)
}

// required uint64 src_offset = 2;
inline bool MGMove::has_src_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGMove::set_has_src_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGMove::clear_has_src_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGMove::clear_src_offset() {
  src_offset_ = GOOGLE_ULONGLONG(0);
  clear_has_src_offset();
}
inline ::google::protobuf::uint64 MGMove::src_offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGMove.src_offset)
  return src_offset_;
}
inline void MGMove::set_src_offset(::google::protobuf::uint64 value) {
  set_has_src_offset();
  src_offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGMove.src_offset)
}

// required int32 dst_loc = 3;
inline bool MGMove::has_dst_loc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGMove::set_has_dst_loc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGMove::clear_has_dst_loc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGMove::clear_dst_loc() {
  dst_loc_ = 0;
  clear_has_dst_loc();
}
inline ::google::protobuf::int32 MGMove::dst_loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGMove.dst_loc)
  return dst_loc_;
}
inline void MGMove::set_dst_loc(::google::protobuf::int32 value) {
  set_has_dst_loc();
  dst_loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGMove.dst_loc)
}

// required uint64 dst_offset = 4;
inline bool MGMove::has_dst_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MGMove::set_has_dst_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MGMove::clear_has_dst_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MGMove::clear_dst_offset() {
  dst_offset_ = GOOGLE_ULONGLONG(0);
  clear_has_dst_offset();
}
inline ::google::protobuf::uint64 MGMove::dst_offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGMove.dst_offset)
  return dst_offset_;
}
inline void MGMove::set_dst_offset(::google::protobuf::uint64 value) {
  set_has_dst_offset();
  dst_offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGMove.dst_offset)
}

// required uint64 size = 5;
inline bool MGMove::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MGMove::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MGMove::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MGMove::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MGMove::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MGMove.size)
  return size_;
}
inline void MGMove::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGMove.size)
}

// -------------------------------------------------------------------

// MGEvict

// required int32 storage_loc = 1;
inline bool MGEvict::has_storage_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGEvict::set_has_storage_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGEvict::clear_has_storage_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGEvict::clear_storage_loc() {
  storage_loc_ = 0;
  clear_has_storage_loc();
}
inline ::google::protobuf::int32 MGEvict::storage_loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGEvict.storage_loc)
  return storage_loc_;
}
inline void MGEvict::set_storage_loc(::google::protobuf::int32 value) {
  set_has_storage_loc();
  storage_loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGEvict.storage_loc)
}

// required int32 storage_id = 2;
inline bool MGEvict::has_storage_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGEvict::set_has_storage_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGEvict::clear_has_storage_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGEvict::clear_storage_id() {
  storage_id_ = 0;
  clear_has_storage_id();
}
inline ::google::protobuf::int32 MGEvict::storage_id() const {
  // @@protoc_insertion_point(field_get:es_proto.MGEvict.storage_id)
  return storage_id_;
}
inline void MGEvict::set_storage_id(::google::protobuf::int32 value) {
  set_has_storage_id();
  storage_id_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGEvict.storage_id)
}

// required int32 loc = 3;
inline bool MGEvict::has_loc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MGEvict::set_has_loc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MGEvict::clear_has_loc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MGEvict::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MGEvict::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGEvict.loc)
  return loc_;
}
inline void MGEvict::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGEvict.loc)
}

// required uint64 offset = 4;
inline bool MGEvict::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGEvict::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGEvict::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGEvict::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MGEvict::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGEvict.offset)
  return offset_;
}
inline void MGEvict::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGEvict.offset)
}

// required uint64 size = 5;
inline bool MGEvict::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MGEvict::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MGEvict::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MGEvict::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MGEvict::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MGEvict.size)
  return size_;
}
inline void MGEvict::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGEvict.size)
}

// -------------------------------------------------------------------

// MGLoad

// required int32 storage_loc = 1;
inline bool MGLoad::has_storage_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGLoad::set_has_storage_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGLoad::clear_has_storage_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGLoad::clear_storage_loc() {
  storage_loc_ = 0;
  clear_has_storage_loc();
}
inline ::google::protobuf::int32 MGLoad::storage_loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGLoad.storage_loc)
  return storage_loc_;
}
inline void MGLoad::set_storage_loc(::google::protobuf::int32 value) {
  set_has_storage_loc();
  storage_loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGLoad.storage_loc)
}

// required int32 storage_id = 2;
inline bool MGLoad::has_storage_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGLoad::set_has_storage_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGLoad::clear_has_storage_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGLoad::clear_storage_id() {
  storage_id_ = 0;
  clear_has_storage_id();
}
inline ::google::protobuf::int32 MGLoad::storage_id() const {
  // @@protoc_insertion_point(field_get:es_proto.MGLoad.storage_id)
  return storage_id_;
}
inline void MGLoad::set_storage_id(::google::protobuf::int32 value) {
  set_has_storage_id();
  storage_id_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGLoad.storage_id)
}

// required int32 loc = 3;
inline bool MGLoad::has_loc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MGLoad::set_has_loc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MGLoad::clear_has_loc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MGLoad::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MGLoad::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGLoad.loc)
  return loc_;
}
inline void MGLoad::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGLoad.loc)
}

// required uint64 offset = 4;
inline bool MGLoad::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGLoad::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGLoad::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGLoad::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MGLoad::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGLoad.offset)
  return offset_;
}
inline void MGLoad::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGLoad.offset)
}

// required uint64 size = 5;
inline bool MGLoad::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MGLoad::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MGLoad::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MGLoad::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MGLoad::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MGLoad.size)
  return size_;
}
inline void MGLoad::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGLoad.size)
}

// -------------------------------------------------------------------

// MGPartialize

// required int32 loc = 1;
inline bool MGPartialize::has_loc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGPartialize::set_has_loc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGPartialize::clear_has_loc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGPartialize::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MGPartialize::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGPartialize.loc)
  return loc_;
}
inline void MGPartialize::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGPartialize.loc)
}

// required uint64 offset = 2;
inline bool MGPartialize::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGPartialize::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGPartialize::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGPartialize::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MGPartialize::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGPartialize.offset)
  return offset_;
}
inline void MGPartialize::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGPartialize.offset)
}

// required uint64 size = 3;
inline bool MGPartialize::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGPartialize::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGPartialize::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGPartialize::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MGPartialize::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MGPartialize.size)
  return size_;
}
inline void MGPartialize::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGPartialize.size)
}

// -------------------------------------------------------------------

// MGAlloc

// required int32 loc = 1;
inline bool MGAlloc::has_loc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGAlloc::set_has_loc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGAlloc::clear_has_loc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGAlloc::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MGAlloc::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGAlloc.loc)
  return loc_;
}
inline void MGAlloc::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGAlloc.loc)
}

// required uint64 offset = 2;
inline bool MGAlloc::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGAlloc::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGAlloc::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGAlloc::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MGAlloc::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGAlloc.offset)
  return offset_;
}
inline void MGAlloc::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGAlloc.offset)
}

// required uint64 size = 3;
inline bool MGAlloc::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGAlloc::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGAlloc::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGAlloc::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MGAlloc::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MGAlloc.size)
  return size_;
}
inline void MGAlloc::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGAlloc.size)
}

// -------------------------------------------------------------------

// MGDel

// required int32 loc = 1;
inline bool MGDel::has_loc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MGDel::set_has_loc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MGDel::clear_has_loc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MGDel::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MGDel::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MGDel.loc)
  return loc_;
}
inline void MGDel::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGDel.loc)
}

// required uint64 offset = 2;
inline bool MGDel::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MGDel::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MGDel::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MGDel::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MGDel::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MGDel.offset)
  return offset_;
}
inline void MGDel::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGDel.offset)
}

// required uint64 size = 3;
inline bool MGDel::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MGDel::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MGDel::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MGDel::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MGDel::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MGDel.size)
  return size_;
}
inline void MGDel::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MGDel.size)
}

// -------------------------------------------------------------------

// MemGraphNode

// optional .es_proto.MGInputMem inputmem = 1;
inline bool MemGraphNode::has_inputmem() const {
  return node_case() == kInputmem;
}
inline void MemGraphNode::set_has_inputmem() {
  _oneof_case_[0] = kInputmem;
}
inline void MemGraphNode::clear_inputmem() {
  if (has_inputmem()) {
    delete node_.inputmem_;
    clear_has_node();
  }
}
inline const ::es_proto::MGInputMem& MemGraphNode::_internal_inputmem() const {
  return *node_.inputmem_;
}
inline ::es_proto::MGInputMem* MemGraphNode::release_inputmem() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.inputmem)
  if (has_inputmem()) {
    clear_has_node();
      ::es_proto::MGInputMem* temp = node_.inputmem_;
    node_.inputmem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGInputMem& MemGraphNode::inputmem() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.inputmem)
  return has_inputmem()
      ? *node_.inputmem_
      : *reinterpret_cast< ::es_proto::MGInputMem*>(&::es_proto::_MGInputMem_default_instance_);
}
inline ::es_proto::MGInputMem* MemGraphNode::mutable_inputmem() {
  if (!has_inputmem()) {
    clear_node();
    set_has_inputmem();
    node_.inputmem_ = CreateMaybeMessage< ::es_proto::MGInputMem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.inputmem)
  return node_.inputmem_;
}

// optional .es_proto.MGInputSto inputsto = 2;
inline bool MemGraphNode::has_inputsto() const {
  return node_case() == kInputsto;
}
inline void MemGraphNode::set_has_inputsto() {
  _oneof_case_[0] = kInputsto;
}
inline void MemGraphNode::clear_inputsto() {
  if (has_inputsto()) {
    delete node_.inputsto_;
    clear_has_node();
  }
}
inline const ::es_proto::MGInputSto& MemGraphNode::_internal_inputsto() const {
  return *node_.inputsto_;
}
inline ::es_proto::MGInputSto* MemGraphNode::release_inputsto() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.inputsto)
  if (has_inputsto()) {
    clear_has_node();
      ::es_proto::MGInputSto* temp = node_.inputsto_;
    node_.inputsto_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGInputSto& MemGraphNode::inputsto() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.inputsto)
  return has_inputsto()
      ? *node_.inputsto_
      : *reinterpret_cast< ::es_proto::MGInputSto*>(&::es_proto::_MGInputSto_default_instance_);
}
inline ::es_proto::MGInputSto* MemGraphNode::mutable_inputsto() {
  if (!has_inputsto()) {
    clear_node();
    set_has_inputsto();
    node_.inputsto_ = CreateMaybeMessage< ::es_proto::MGInputSto >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.inputsto)
  return node_.inputsto_;
}

// optional .es_proto.MGConstant constant = 3;
inline bool MemGraphNode::has_constant() const {
  return node_case() == kConstant;
}
inline void MemGraphNode::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void MemGraphNode::clear_constant() {
  if (has_constant()) {
    delete node_.constant_;
    clear_has_node();
  }
}
inline const ::es_proto::MGConstant& MemGraphNode::_internal_constant() const {
  return *node_.constant_;
}
inline ::es_proto::MGConstant* MemGraphNode::release_constant() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.constant)
  if (has_constant()) {
    clear_has_node();
      ::es_proto::MGConstant* temp = node_.constant_;
    node_.constant_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGConstant& MemGraphNode::constant() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.constant)
  return has_constant()
      ? *node_.constant_
      : *reinterpret_cast< ::es_proto::MGConstant*>(&::es_proto::_MGConstant_default_instance_);
}
inline ::es_proto::MGConstant* MemGraphNode::mutable_constant() {
  if (!has_constant()) {
    clear_node();
    set_has_constant();
    node_.constant_ = CreateMaybeMessage< ::es_proto::MGConstant >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.constant)
  return node_.constant_;
}

// optional .es_proto.MGApply apply = 4;
inline bool MemGraphNode::has_apply() const {
  return node_case() == kApply;
}
inline void MemGraphNode::set_has_apply() {
  _oneof_case_[0] = kApply;
}
inline void MemGraphNode::clear_apply() {
  if (has_apply()) {
    delete node_.apply_;
    clear_has_node();
  }
}
inline const ::es_proto::MGApply& MemGraphNode::_internal_apply() const {
  return *node_.apply_;
}
inline ::es_proto::MGApply* MemGraphNode::release_apply() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.apply)
  if (has_apply()) {
    clear_has_node();
      ::es_proto::MGApply* temp = node_.apply_;
    node_.apply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGApply& MemGraphNode::apply() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.apply)
  return has_apply()
      ? *node_.apply_
      : *reinterpret_cast< ::es_proto::MGApply*>(&::es_proto::_MGApply_default_instance_);
}
inline ::es_proto::MGApply* MemGraphNode::mutable_apply() {
  if (!has_apply()) {
    clear_node();
    set_has_apply();
    node_.apply_ = CreateMaybeMessage< ::es_proto::MGApply >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.apply)
  return node_.apply_;
}

// optional .es_proto.MGMove move = 5;
inline bool MemGraphNode::has_move() const {
  return node_case() == kMove;
}
inline void MemGraphNode::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void MemGraphNode::clear_move() {
  if (has_move()) {
    delete node_.move_;
    clear_has_node();
  }
}
inline const ::es_proto::MGMove& MemGraphNode::_internal_move() const {
  return *node_.move_;
}
inline ::es_proto::MGMove* MemGraphNode::release_move() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.move)
  if (has_move()) {
    clear_has_node();
      ::es_proto::MGMove* temp = node_.move_;
    node_.move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGMove& MemGraphNode::move() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.move)
  return has_move()
      ? *node_.move_
      : *reinterpret_cast< ::es_proto::MGMove*>(&::es_proto::_MGMove_default_instance_);
}
inline ::es_proto::MGMove* MemGraphNode::mutable_move() {
  if (!has_move()) {
    clear_node();
    set_has_move();
    node_.move_ = CreateMaybeMessage< ::es_proto::MGMove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.move)
  return node_.move_;
}

// optional .es_proto.MGEvict evict = 6;
inline bool MemGraphNode::has_evict() const {
  return node_case() == kEvict;
}
inline void MemGraphNode::set_has_evict() {
  _oneof_case_[0] = kEvict;
}
inline void MemGraphNode::clear_evict() {
  if (has_evict()) {
    delete node_.evict_;
    clear_has_node();
  }
}
inline const ::es_proto::MGEvict& MemGraphNode::_internal_evict() const {
  return *node_.evict_;
}
inline ::es_proto::MGEvict* MemGraphNode::release_evict() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.evict)
  if (has_evict()) {
    clear_has_node();
      ::es_proto::MGEvict* temp = node_.evict_;
    node_.evict_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGEvict& MemGraphNode::evict() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.evict)
  return has_evict()
      ? *node_.evict_
      : *reinterpret_cast< ::es_proto::MGEvict*>(&::es_proto::_MGEvict_default_instance_);
}
inline ::es_proto::MGEvict* MemGraphNode::mutable_evict() {
  if (!has_evict()) {
    clear_node();
    set_has_evict();
    node_.evict_ = CreateMaybeMessage< ::es_proto::MGEvict >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.evict)
  return node_.evict_;
}

// optional .es_proto.MGLoad load = 7;
inline bool MemGraphNode::has_load() const {
  return node_case() == kLoad;
}
inline void MemGraphNode::set_has_load() {
  _oneof_case_[0] = kLoad;
}
inline void MemGraphNode::clear_load() {
  if (has_load()) {
    delete node_.load_;
    clear_has_node();
  }
}
inline const ::es_proto::MGLoad& MemGraphNode::_internal_load() const {
  return *node_.load_;
}
inline ::es_proto::MGLoad* MemGraphNode::release_load() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.load)
  if (has_load()) {
    clear_has_node();
      ::es_proto::MGLoad* temp = node_.load_;
    node_.load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGLoad& MemGraphNode::load() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.load)
  return has_load()
      ? *node_.load_
      : *reinterpret_cast< ::es_proto::MGLoad*>(&::es_proto::_MGLoad_default_instance_);
}
inline ::es_proto::MGLoad* MemGraphNode::mutable_load() {
  if (!has_load()) {
    clear_node();
    set_has_load();
    node_.load_ = CreateMaybeMessage< ::es_proto::MGLoad >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.load)
  return node_.load_;
}

// optional .es_proto.MGPartialize partialize = 8;
inline bool MemGraphNode::has_partialize() const {
  return node_case() == kPartialize;
}
inline void MemGraphNode::set_has_partialize() {
  _oneof_case_[0] = kPartialize;
}
inline void MemGraphNode::clear_partialize() {
  if (has_partialize()) {
    delete node_.partialize_;
    clear_has_node();
  }
}
inline const ::es_proto::MGPartialize& MemGraphNode::_internal_partialize() const {
  return *node_.partialize_;
}
inline ::es_proto::MGPartialize* MemGraphNode::release_partialize() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.partialize)
  if (has_partialize()) {
    clear_has_node();
      ::es_proto::MGPartialize* temp = node_.partialize_;
    node_.partialize_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGPartialize& MemGraphNode::partialize() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.partialize)
  return has_partialize()
      ? *node_.partialize_
      : *reinterpret_cast< ::es_proto::MGPartialize*>(&::es_proto::_MGPartialize_default_instance_);
}
inline ::es_proto::MGPartialize* MemGraphNode::mutable_partialize() {
  if (!has_partialize()) {
    clear_node();
    set_has_partialize();
    node_.partialize_ = CreateMaybeMessage< ::es_proto::MGPartialize >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.partialize)
  return node_.partialize_;
}

// optional .es_proto.MGAlloc alloc = 9;
inline bool MemGraphNode::has_alloc() const {
  return node_case() == kAlloc;
}
inline void MemGraphNode::set_has_alloc() {
  _oneof_case_[0] = kAlloc;
}
inline void MemGraphNode::clear_alloc() {
  if (has_alloc()) {
    delete node_.alloc_;
    clear_has_node();
  }
}
inline const ::es_proto::MGAlloc& MemGraphNode::_internal_alloc() const {
  return *node_.alloc_;
}
inline ::es_proto::MGAlloc* MemGraphNode::release_alloc() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.alloc)
  if (has_alloc()) {
    clear_has_node();
      ::es_proto::MGAlloc* temp = node_.alloc_;
    node_.alloc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGAlloc& MemGraphNode::alloc() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.alloc)
  return has_alloc()
      ? *node_.alloc_
      : *reinterpret_cast< ::es_proto::MGAlloc*>(&::es_proto::_MGAlloc_default_instance_);
}
inline ::es_proto::MGAlloc* MemGraphNode::mutable_alloc() {
  if (!has_alloc()) {
    clear_node();
    set_has_alloc();
    node_.alloc_ = CreateMaybeMessage< ::es_proto::MGAlloc >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.alloc)
  return node_.alloc_;
}

// optional .es_proto.MGDel del = 10;
inline bool MemGraphNode::has_del() const {
  return node_case() == kDel;
}
inline void MemGraphNode::set_has_del() {
  _oneof_case_[0] = kDel;
}
inline void MemGraphNode::clear_del() {
  if (has_del()) {
    delete node_.del_;
    clear_has_node();
  }
}
inline const ::es_proto::MGDel& MemGraphNode::_internal_del() const {
  return *node_.del_;
}
inline ::es_proto::MGDel* MemGraphNode::release_del() {
  // @@protoc_insertion_point(field_release:es_proto.MemGraphNode.del)
  if (has_del()) {
    clear_has_node();
      ::es_proto::MGDel* temp = node_.del_;
    node_.del_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::MGDel& MemGraphNode::del() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.del)
  return has_del()
      ? *node_.del_
      : *reinterpret_cast< ::es_proto::MGDel*>(&::es_proto::_MGDel_default_instance_);
}
inline ::es_proto::MGDel* MemGraphNode::mutable_del() {
  if (!has_del()) {
    clear_node();
    set_has_del();
    node_.del_ = CreateMaybeMessage< ::es_proto::MGDel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraphNode.del)
  return node_.del_;
}

// repeated int32 inns = 11;
inline int MemGraphNode::inns_size() const {
  return inns_.size();
}
inline void MemGraphNode::clear_inns() {
  inns_.Clear();
}
inline ::google::protobuf::int32 MemGraphNode::inns(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraphNode.inns)
  return inns_.Get(index);
}
inline void MemGraphNode::set_inns(int index, ::google::protobuf::int32 value) {
  inns_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.MemGraphNode.inns)
}
inline void MemGraphNode::add_inns(::google::protobuf::int32 value) {
  inns_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.MemGraphNode.inns)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MemGraphNode::inns() const {
  // @@protoc_insertion_point(field_list:es_proto.MemGraphNode.inns)
  return inns_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MemGraphNode::mutable_inns() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.MemGraphNode.inns)
  return &inns_;
}

inline bool MemGraphNode::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void MemGraphNode::clear_has_node() {
  _oneof_case_[0] = NODE_NOT_SET;
}
inline MemGraphNode::NodeCase MemGraphNode::node_case() const {
  return MemGraphNode::NodeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MemGraph

// required int32 num_compute_locs = 1;
inline bool MemGraph::has_num_compute_locs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemGraph::set_has_num_compute_locs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemGraph::clear_has_num_compute_locs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemGraph::clear_num_compute_locs() {
  num_compute_locs_ = 0;
  clear_has_num_compute_locs();
}
inline ::google::protobuf::int32 MemGraph::num_compute_locs() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraph.num_compute_locs)
  return num_compute_locs_;
}
inline void MemGraph::set_num_compute_locs(::google::protobuf::int32 value) {
  set_has_num_compute_locs();
  num_compute_locs_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MemGraph.num_compute_locs)
}

// required int32 num_storage_locs = 2;
inline bool MemGraph::has_num_storage_locs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemGraph::set_has_num_storage_locs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemGraph::clear_has_num_storage_locs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemGraph::clear_num_storage_locs() {
  num_storage_locs_ = 0;
  clear_has_num_storage_locs();
}
inline ::google::protobuf::int32 MemGraph::num_storage_locs() const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraph.num_storage_locs)
  return num_storage_locs_;
}
inline void MemGraph::set_num_storage_locs(::google::protobuf::int32 value) {
  set_has_num_storage_locs();
  num_storage_locs_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MemGraph.num_storage_locs)
}

// repeated int32 storage_locs = 3;
inline int MemGraph::storage_locs_size() const {
  return storage_locs_.size();
}
inline void MemGraph::clear_storage_locs() {
  storage_locs_.Clear();
}
inline ::google::protobuf::int32 MemGraph::storage_locs(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraph.storage_locs)
  return storage_locs_.Get(index);
}
inline void MemGraph::set_storage_locs(int index, ::google::protobuf::int32 value) {
  storage_locs_.Set(index, value);
  // @@protoc_insertion_point(field_set:es_proto.MemGraph.storage_locs)
}
inline void MemGraph::add_storage_locs(::google::protobuf::int32 value) {
  storage_locs_.Add(value);
  // @@protoc_insertion_point(field_add:es_proto.MemGraph.storage_locs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MemGraph::storage_locs() const {
  // @@protoc_insertion_point(field_list:es_proto.MemGraph.storage_locs)
  return storage_locs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MemGraph::mutable_storage_locs() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.MemGraph.storage_locs)
  return &storage_locs_;
}

// repeated .es_proto.MemGraphNode nodes = 4;
inline int MemGraph::nodes_size() const {
  return nodes_.size();
}
inline void MemGraph::clear_nodes() {
  nodes_.Clear();
}
inline ::es_proto::MemGraphNode* MemGraph::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.MemGraph.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::MemGraphNode >*
MemGraph::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.MemGraph.nodes)
  return &nodes_;
}
inline const ::es_proto::MemGraphNode& MemGraph::nodes(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.MemGraph.nodes)
  return nodes_.Get(index);
}
inline ::es_proto::MemGraphNode* MemGraph::add_nodes() {
  // @@protoc_insertion_point(field_add:es_proto.MemGraph.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::MemGraphNode >&
MemGraph::nodes() const {
  // @@protoc_insertion_point(field_list:es_proto.MemGraph.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// Mem

// required uint64 offset = 1;
inline bool Mem::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mem::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mem::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mem::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Mem::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.Mem.offset)
  return offset_;
}
inline void Mem::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.Mem.offset)
}

// required uint64 size = 2;
inline bool Mem::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mem::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mem::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mem::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 Mem::size() const {
  // @@protoc_insertion_point(field_get:es_proto.Mem.size)
  return size_;
}
inline void Mem::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.Mem.size)
}

// -------------------------------------------------------------------

// MemLoc

// required uint64 offset = 1;
inline bool MemLoc::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemLoc::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemLoc::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemLoc::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MemLoc::offset() const {
  // @@protoc_insertion_point(field_get:es_proto.MemLoc.offset)
  return offset_;
}
inline void MemLoc::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MemLoc.offset)
}

// required uint64 size = 2;
inline bool MemLoc::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemLoc::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemLoc::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemLoc::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MemLoc::size() const {
  // @@protoc_insertion_point(field_get:es_proto.MemLoc.size)
  return size_;
}
inline void MemLoc::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MemLoc.size)
}

// required int32 loc = 3;
inline bool MemLoc::has_loc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemLoc::set_has_loc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemLoc::clear_has_loc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemLoc::clear_loc() {
  loc_ = 0;
  clear_has_loc();
}
inline ::google::protobuf::int32 MemLoc::loc() const {
  // @@protoc_insertion_point(field_get:es_proto.MemLoc.loc)
  return loc_;
}
inline void MemLoc::set_loc(::google::protobuf::int32 value) {
  set_has_loc();
  loc_ = value;
  // @@protoc_insertion_point(field_set:es_proto.MemLoc.loc)
}

// -------------------------------------------------------------------

// IEInit

// required int32 world_size = 1;
inline bool IEInit::has_world_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IEInit::set_has_world_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IEInit::clear_has_world_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IEInit::clear_world_size() {
  world_size_ = 0;
  clear_has_world_size();
}
inline ::google::protobuf::int32 IEInit::world_size() const {
  // @@protoc_insertion_point(field_get:es_proto.IEInit.world_size)
  return world_size_;
}
inline void IEInit::set_world_size(::google::protobuf::int32 value) {
  set_has_world_size();
  world_size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IEInit.world_size)
}

// required uint64 mem_size = 2;
inline bool IEInit::has_mem_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IEInit::set_has_mem_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IEInit::clear_has_mem_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IEInit::clear_mem_size() {
  mem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_size();
}
inline ::google::protobuf::uint64 IEInit::mem_size() const {
  // @@protoc_insertion_point(field_get:es_proto.IEInit.mem_size)
  return mem_size_;
}
inline void IEInit::set_mem_size(::google::protobuf::uint64 value) {
  set_has_mem_size();
  mem_size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IEInit.mem_size)
}

// required int32 num_threads = 3;
inline bool IEInit::has_num_threads() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IEInit::set_has_num_threads() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IEInit::clear_has_num_threads() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IEInit::clear_num_threads() {
  num_threads_ = 0;
  clear_has_num_threads();
}
inline ::google::protobuf::int32 IEInit::num_threads() const {
  // @@protoc_insertion_point(field_get:es_proto.IEInit.num_threads)
  return num_threads_;
}
inline void IEInit::set_num_threads(::google::protobuf::int32 value) {
  set_has_num_threads();
  num_threads_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IEInit.num_threads)
}

// required int32 num_files = 4;
inline bool IEInit::has_num_files() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IEInit::set_has_num_files() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IEInit::clear_has_num_files() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IEInit::clear_num_files() {
  num_files_ = 0;
  clear_has_num_files();
}
inline ::google::protobuf::int32 IEInit::num_files() const {
  // @@protoc_insertion_point(field_get:es_proto.IEInit.num_files)
  return num_files_;
}
inline void IEInit::set_num_files(::google::protobuf::int32 value) {
  set_has_num_files();
  num_files_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IEInit.num_files)
}

// required uint64 batch_size = 5;
inline bool IEInit::has_batch_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IEInit::set_has_batch_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IEInit::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IEInit::clear_batch_size() {
  batch_size_ = GOOGLE_ULONGLONG(0);
  clear_has_batch_size();
}
inline ::google::protobuf::uint64 IEInit::batch_size() const {
  // @@protoc_insertion_point(field_get:es_proto.IEInit.batch_size)
  return batch_size_;
}
inline void IEInit::set_batch_size(::google::protobuf::uint64 value) {
  set_has_batch_size();
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IEInit.batch_size)
}

// required uint64 seq_len = 6;
inline bool IEInit::has_seq_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IEInit::set_has_seq_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IEInit::clear_has_seq_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IEInit::clear_seq_len() {
  seq_len_ = GOOGLE_ULONGLONG(0);
  clear_has_seq_len();
}
inline ::google::protobuf::uint64 IEInit::seq_len() const {
  // @@protoc_insertion_point(field_get:es_proto.IEInit.seq_len)
  return seq_len_;
}
inline void IEInit::set_seq_len(::google::protobuf::uint64 value) {
  set_has_seq_len();
  seq_len_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IEInit.seq_len)
}

// -------------------------------------------------------------------

// IECloseReaders

// required int32 dummy = 1;
inline bool IECloseReaders::has_dummy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IECloseReaders::set_has_dummy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IECloseReaders::clear_has_dummy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IECloseReaders::clear_dummy() {
  dummy_ = 0;
  clear_has_dummy();
}
inline ::google::protobuf::int32 IECloseReaders::dummy() const {
  // @@protoc_insertion_point(field_get:es_proto.IECloseReaders.dummy)
  return dummy_;
}
inline void IECloseReaders::set_dummy(::google::protobuf::int32 value) {
  set_has_dummy();
  dummy_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IECloseReaders.dummy)
}

// -------------------------------------------------------------------

// IELoadWeight

// required string name = 1;
inline bool IELoadWeight::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IELoadWeight::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IELoadWeight::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IELoadWeight::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& IELoadWeight::name() const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadWeight.name)
  return name_.GetNoArena();
}
inline void IELoadWeight::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.IELoadWeight.name)
}
#if LANG_CXX11
inline void IELoadWeight::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.IELoadWeight.name)
}
#endif
inline void IELoadWeight::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.IELoadWeight.name)
}
inline void IELoadWeight::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.IELoadWeight.name)
}
inline ::std::string* IELoadWeight::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:es_proto.IELoadWeight.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IELoadWeight::release_name() {
  // @@protoc_insertion_point(field_release:es_proto.IELoadWeight.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IELoadWeight::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:es_proto.IELoadWeight.name)
}

// repeated .es_proto.MemLoc data_locs = 2;
inline int IELoadWeight::data_locs_size() const {
  return data_locs_.size();
}
inline void IELoadWeight::clear_data_locs() {
  data_locs_.Clear();
}
inline ::es_proto::MemLoc* IELoadWeight::mutable_data_locs(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.IELoadWeight.data_locs)
  return data_locs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >*
IELoadWeight::mutable_data_locs() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.IELoadWeight.data_locs)
  return &data_locs_;
}
inline const ::es_proto::MemLoc& IELoadWeight::data_locs(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadWeight.data_locs)
  return data_locs_.Get(index);
}
inline ::es_proto::MemLoc* IELoadWeight::add_data_locs() {
  // @@protoc_insertion_point(field_add:es_proto.IELoadWeight.data_locs)
  return data_locs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >&
IELoadWeight::data_locs() const {
  // @@protoc_insertion_point(field_list:es_proto.IELoadWeight.data_locs)
  return data_locs_;
}

// -------------------------------------------------------------------

// IELoadDataMatrix

// required uint64 batch_size = 1;
inline bool IELoadDataMatrix::has_batch_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IELoadDataMatrix::set_has_batch_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IELoadDataMatrix::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IELoadDataMatrix::clear_batch_size() {
  batch_size_ = GOOGLE_ULONGLONG(0);
  clear_has_batch_size();
}
inline ::google::protobuf::uint64 IELoadDataMatrix::batch_size() const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadDataMatrix.batch_size)
  return batch_size_;
}
inline void IELoadDataMatrix::set_batch_size(::google::protobuf::uint64 value) {
  set_has_batch_size();
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IELoadDataMatrix.batch_size)
}

// required uint64 seq_len = 2;
inline bool IELoadDataMatrix::has_seq_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IELoadDataMatrix::set_has_seq_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IELoadDataMatrix::clear_has_seq_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IELoadDataMatrix::clear_seq_len() {
  seq_len_ = GOOGLE_ULONGLONG(0);
  clear_has_seq_len();
}
inline ::google::protobuf::uint64 IELoadDataMatrix::seq_len() const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadDataMatrix.seq_len)
  return seq_len_;
}
inline void IELoadDataMatrix::set_seq_len(::google::protobuf::uint64 value) {
  set_has_seq_len();
  seq_len_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IELoadDataMatrix.seq_len)
}

// required uint64 d_embed = 3;
inline bool IELoadDataMatrix::has_d_embed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IELoadDataMatrix::set_has_d_embed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IELoadDataMatrix::clear_has_d_embed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IELoadDataMatrix::clear_d_embed() {
  d_embed_ = GOOGLE_ULONGLONG(0);
  clear_has_d_embed();
}
inline ::google::protobuf::uint64 IELoadDataMatrix::d_embed() const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadDataMatrix.d_embed)
  return d_embed_;
}
inline void IELoadDataMatrix::set_d_embed(::google::protobuf::uint64 value) {
  set_has_d_embed();
  d_embed_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IELoadDataMatrix.d_embed)
}

// required .es_proto.Mem mem = 4;
inline bool IELoadDataMatrix::has_mem() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IELoadDataMatrix::set_has_mem() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IELoadDataMatrix::clear_has_mem() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IELoadDataMatrix::clear_mem() {
  if (mem_ != NULL) mem_->Clear();
  clear_has_mem();
}
inline const ::es_proto::Mem& IELoadDataMatrix::_internal_mem() const {
  return *mem_;
}
inline const ::es_proto::Mem& IELoadDataMatrix::mem() const {
  const ::es_proto::Mem* p = mem_;
  // @@protoc_insertion_point(field_get:es_proto.IELoadDataMatrix.mem)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Mem*>(
      &::es_proto::_Mem_default_instance_);
}
inline ::es_proto::Mem* IELoadDataMatrix::release_mem() {
  // @@protoc_insertion_point(field_release:es_proto.IELoadDataMatrix.mem)
  clear_has_mem();
  ::es_proto::Mem* temp = mem_;
  mem_ = NULL;
  return temp;
}
inline ::es_proto::Mem* IELoadDataMatrix::mutable_mem() {
  set_has_mem();
  if (mem_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Mem>(GetArenaNoVirtual());
    mem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.IELoadDataMatrix.mem)
  return mem_;
}
inline void IELoadDataMatrix::set_allocated_mem(::es_proto::Mem* mem) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mem_;
  }
  if (mem) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mem = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mem, submessage_arena);
    }
    set_has_mem();
  } else {
    clear_has_mem();
  }
  mem_ = mem;
  // @@protoc_insertion_point(field_set_allocated:es_proto.IELoadDataMatrix.mem)
}

// -------------------------------------------------------------------

// IELoadMask

// required uint64 seq_len = 1;
inline bool IELoadMask::has_seq_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IELoadMask::set_has_seq_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IELoadMask::clear_has_seq_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IELoadMask::clear_seq_len() {
  seq_len_ = GOOGLE_ULONGLONG(0);
  clear_has_seq_len();
}
inline ::google::protobuf::uint64 IELoadMask::seq_len() const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadMask.seq_len)
  return seq_len_;
}
inline void IELoadMask::set_seq_len(::google::protobuf::uint64 value) {
  set_has_seq_len();
  seq_len_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IELoadMask.seq_len)
}

// required .es_proto.Mem mem = 2;
inline bool IELoadMask::has_mem() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IELoadMask::set_has_mem() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IELoadMask::clear_has_mem() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IELoadMask::clear_mem() {
  if (mem_ != NULL) mem_->Clear();
  clear_has_mem();
}
inline const ::es_proto::Mem& IELoadMask::_internal_mem() const {
  return *mem_;
}
inline const ::es_proto::Mem& IELoadMask::mem() const {
  const ::es_proto::Mem* p = mem_;
  // @@protoc_insertion_point(field_get:es_proto.IELoadMask.mem)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Mem*>(
      &::es_proto::_Mem_default_instance_);
}
inline ::es_proto::Mem* IELoadMask::release_mem() {
  // @@protoc_insertion_point(field_release:es_proto.IELoadMask.mem)
  clear_has_mem();
  ::es_proto::Mem* temp = mem_;
  mem_ = NULL;
  return temp;
}
inline ::es_proto::Mem* IELoadMask::mutable_mem() {
  set_has_mem();
  if (mem_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Mem>(GetArenaNoVirtual());
    mem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.IELoadMask.mem)
  return mem_;
}
inline void IELoadMask::set_allocated_mem(::es_proto::Mem* mem) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mem_;
  }
  if (mem) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mem = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mem, submessage_arena);
    }
    set_has_mem();
  } else {
    clear_has_mem();
  }
  mem_ = mem;
  // @@protoc_insertion_point(field_set_allocated:es_proto.IELoadMask.mem)
}

// -------------------------------------------------------------------

// IELoadFreqsCis

// required uint64 dim = 1;
inline bool IELoadFreqsCis::has_dim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IELoadFreqsCis::set_has_dim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IELoadFreqsCis::clear_has_dim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IELoadFreqsCis::clear_dim() {
  dim_ = GOOGLE_ULONGLONG(0);
  clear_has_dim();
}
inline ::google::protobuf::uint64 IELoadFreqsCis::dim() const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadFreqsCis.dim)
  return dim_;
}
inline void IELoadFreqsCis::set_dim(::google::protobuf::uint64 value) {
  set_has_dim();
  dim_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IELoadFreqsCis.dim)
}

// required uint64 heads = 2;
inline bool IELoadFreqsCis::has_heads() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IELoadFreqsCis::set_has_heads() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IELoadFreqsCis::clear_has_heads() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IELoadFreqsCis::clear_heads() {
  heads_ = GOOGLE_ULONGLONG(0);
  clear_has_heads();
}
inline ::google::protobuf::uint64 IELoadFreqsCis::heads() const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadFreqsCis.heads)
  return heads_;
}
inline void IELoadFreqsCis::set_heads(::google::protobuf::uint64 value) {
  set_has_heads();
  heads_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IELoadFreqsCis.heads)
}

// required uint64 max_seq_len = 3;
inline bool IELoadFreqsCis::has_max_seq_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IELoadFreqsCis::set_has_max_seq_len() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IELoadFreqsCis::clear_has_max_seq_len() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IELoadFreqsCis::clear_max_seq_len() {
  max_seq_len_ = GOOGLE_ULONGLONG(0);
  clear_has_max_seq_len();
}
inline ::google::protobuf::uint64 IELoadFreqsCis::max_seq_len() const {
  // @@protoc_insertion_point(field_get:es_proto.IELoadFreqsCis.max_seq_len)
  return max_seq_len_;
}
inline void IELoadFreqsCis::set_max_seq_len(::google::protobuf::uint64 value) {
  set_has_max_seq_len();
  max_seq_len_ = value;
  // @@protoc_insertion_point(field_set:es_proto.IELoadFreqsCis.max_seq_len)
}

// required .es_proto.Mem mem = 4;
inline bool IELoadFreqsCis::has_mem() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IELoadFreqsCis::set_has_mem() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IELoadFreqsCis::clear_has_mem() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IELoadFreqsCis::clear_mem() {
  if (mem_ != NULL) mem_->Clear();
  clear_has_mem();
}
inline const ::es_proto::Mem& IELoadFreqsCis::_internal_mem() const {
  return *mem_;
}
inline const ::es_proto::Mem& IELoadFreqsCis::mem() const {
  const ::es_proto::Mem* p = mem_;
  // @@protoc_insertion_point(field_get:es_proto.IELoadFreqsCis.mem)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Mem*>(
      &::es_proto::_Mem_default_instance_);
}
inline ::es_proto::Mem* IELoadFreqsCis::release_mem() {
  // @@protoc_insertion_point(field_release:es_proto.IELoadFreqsCis.mem)
  clear_has_mem();
  ::es_proto::Mem* temp = mem_;
  mem_ = NULL;
  return temp;
}
inline ::es_proto::Mem* IELoadFreqsCis::mutable_mem() {
  set_has_mem();
  if (mem_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Mem>(GetArenaNoVirtual());
    mem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.IELoadFreqsCis.mem)
  return mem_;
}
inline void IELoadFreqsCis::set_allocated_mem(::es_proto::Mem* mem) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mem_;
  }
  if (mem) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mem = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mem, submessage_arena);
    }
    set_has_mem();
  } else {
    clear_has_mem();
  }
  mem_ = mem;
  // @@protoc_insertion_point(field_set_allocated:es_proto.IELoadFreqsCis.mem)
}

// -------------------------------------------------------------------

// IEExecute

// required string msg = 1;
inline bool IEExecute::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IEExecute::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IEExecute::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IEExecute::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
inline const ::std::string& IEExecute::msg() const {
  // @@protoc_insertion_point(field_get:es_proto.IEExecute.msg)
  return msg_.GetNoArena();
}
inline void IEExecute::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:es_proto.IEExecute.msg)
}
#if LANG_CXX11
inline void IEExecute::set_msg(::std::string&& value) {
  set_has_msg();
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:es_proto.IEExecute.msg)
}
#endif
inline void IEExecute::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:es_proto.IEExecute.msg)
}
inline void IEExecute::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:es_proto.IEExecute.msg)
}
inline ::std::string* IEExecute::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:es_proto.IEExecute.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IEExecute::release_msg() {
  // @@protoc_insertion_point(field_release:es_proto.IEExecute.msg)
  if (!has_msg()) {
    return NULL;
  }
  clear_has_msg();
  return msg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IEExecute::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:es_proto.IEExecute.msg)
}

// required .es_proto.MemGraph memgraph = 2;
inline bool IEExecute::has_memgraph() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IEExecute::set_has_memgraph() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IEExecute::clear_has_memgraph() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IEExecute::clear_memgraph() {
  if (memgraph_ != NULL) memgraph_->Clear();
  clear_has_memgraph();
}
inline const ::es_proto::MemGraph& IEExecute::_internal_memgraph() const {
  return *memgraph_;
}
inline const ::es_proto::MemGraph& IEExecute::memgraph() const {
  const ::es_proto::MemGraph* p = memgraph_;
  // @@protoc_insertion_point(field_get:es_proto.IEExecute.memgraph)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::MemGraph*>(
      &::es_proto::_MemGraph_default_instance_);
}
inline ::es_proto::MemGraph* IEExecute::release_memgraph() {
  // @@protoc_insertion_point(field_release:es_proto.IEExecute.memgraph)
  clear_has_memgraph();
  ::es_proto::MemGraph* temp = memgraph_;
  memgraph_ = NULL;
  return temp;
}
inline ::es_proto::MemGraph* IEExecute::mutable_memgraph() {
  set_has_memgraph();
  if (memgraph_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::MemGraph>(GetArenaNoVirtual());
    memgraph_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.IEExecute.memgraph)
  return memgraph_;
}
inline void IEExecute::set_allocated_memgraph(::es_proto::MemGraph* memgraph) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete memgraph_;
  }
  if (memgraph) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      memgraph = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, memgraph, submessage_arena);
    }
    set_has_memgraph();
  } else {
    clear_has_memgraph();
  }
  memgraph_ = memgraph;
  // @@protoc_insertion_point(field_set_allocated:es_proto.IEExecute.memgraph)
}

// -------------------------------------------------------------------

// IEBuildNext

// required .es_proto.Partition src_part = 1;
inline bool IEBuildNext::has_src_part() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IEBuildNext::set_has_src_part() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IEBuildNext::clear_has_src_part() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IEBuildNext::clear_src_part() {
  if (src_part_ != NULL) src_part_->Clear();
  clear_has_src_part();
}
inline const ::es_proto::Partition& IEBuildNext::_internal_src_part() const {
  return *src_part_;
}
inline const ::es_proto::Partition& IEBuildNext::src_part() const {
  const ::es_proto::Partition* p = src_part_;
  // @@protoc_insertion_point(field_get:es_proto.IEBuildNext.src_part)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Partition*>(
      &::es_proto::_Partition_default_instance_);
}
inline ::es_proto::Partition* IEBuildNext::release_src_part() {
  // @@protoc_insertion_point(field_release:es_proto.IEBuildNext.src_part)
  clear_has_src_part();
  ::es_proto::Partition* temp = src_part_;
  src_part_ = NULL;
  return temp;
}
inline ::es_proto::Partition* IEBuildNext::mutable_src_part() {
  set_has_src_part();
  if (src_part_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Partition>(GetArenaNoVirtual());
    src_part_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.IEBuildNext.src_part)
  return src_part_;
}
inline void IEBuildNext::set_allocated_src_part(::es_proto::Partition* src_part) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete src_part_;
  }
  if (src_part) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      src_part = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src_part, submessage_arena);
    }
    set_has_src_part();
  } else {
    clear_has_src_part();
  }
  src_part_ = src_part;
  // @@protoc_insertion_point(field_set_allocated:es_proto.IEBuildNext.src_part)
}

// repeated .es_proto.MemLoc src_data_locs = 2;
inline int IEBuildNext::src_data_locs_size() const {
  return src_data_locs_.size();
}
inline void IEBuildNext::clear_src_data_locs() {
  src_data_locs_.Clear();
}
inline ::es_proto::MemLoc* IEBuildNext::mutable_src_data_locs(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.IEBuildNext.src_data_locs)
  return src_data_locs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >*
IEBuildNext::mutable_src_data_locs() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.IEBuildNext.src_data_locs)
  return &src_data_locs_;
}
inline const ::es_proto::MemLoc& IEBuildNext::src_data_locs(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.IEBuildNext.src_data_locs)
  return src_data_locs_.Get(index);
}
inline ::es_proto::MemLoc* IEBuildNext::add_src_data_locs() {
  // @@protoc_insertion_point(field_add:es_proto.IEBuildNext.src_data_locs)
  return src_data_locs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >&
IEBuildNext::src_data_locs() const {
  // @@protoc_insertion_point(field_list:es_proto.IEBuildNext.src_data_locs)
  return src_data_locs_;
}

// required .es_proto.Partition dst_part = 3;
inline bool IEBuildNext::has_dst_part() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IEBuildNext::set_has_dst_part() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IEBuildNext::clear_has_dst_part() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IEBuildNext::clear_dst_part() {
  if (dst_part_ != NULL) dst_part_->Clear();
  clear_has_dst_part();
}
inline const ::es_proto::Partition& IEBuildNext::_internal_dst_part() const {
  return *dst_part_;
}
inline const ::es_proto::Partition& IEBuildNext::dst_part() const {
  const ::es_proto::Partition* p = dst_part_;
  // @@protoc_insertion_point(field_get:es_proto.IEBuildNext.dst_part)
  return p != NULL ? *p : *reinterpret_cast<const ::es_proto::Partition*>(
      &::es_proto::_Partition_default_instance_);
}
inline ::es_proto::Partition* IEBuildNext::release_dst_part() {
  // @@protoc_insertion_point(field_release:es_proto.IEBuildNext.dst_part)
  clear_has_dst_part();
  ::es_proto::Partition* temp = dst_part_;
  dst_part_ = NULL;
  return temp;
}
inline ::es_proto::Partition* IEBuildNext::mutable_dst_part() {
  set_has_dst_part();
  if (dst_part_ == NULL) {
    auto* p = CreateMaybeMessage<::es_proto::Partition>(GetArenaNoVirtual());
    dst_part_ = p;
  }
  // @@protoc_insertion_point(field_mutable:es_proto.IEBuildNext.dst_part)
  return dst_part_;
}
inline void IEBuildNext::set_allocated_dst_part(::es_proto::Partition* dst_part) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dst_part_;
  }
  if (dst_part) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dst_part = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dst_part, submessage_arena);
    }
    set_has_dst_part();
  } else {
    clear_has_dst_part();
  }
  dst_part_ = dst_part;
  // @@protoc_insertion_point(field_set_allocated:es_proto.IEBuildNext.dst_part)
}

// repeated .es_proto.MemLoc dst_data_locs = 4;
inline int IEBuildNext::dst_data_locs_size() const {
  return dst_data_locs_.size();
}
inline void IEBuildNext::clear_dst_data_locs() {
  dst_data_locs_.Clear();
}
inline ::es_proto::MemLoc* IEBuildNext::mutable_dst_data_locs(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.IEBuildNext.dst_data_locs)
  return dst_data_locs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >*
IEBuildNext::mutable_dst_data_locs() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.IEBuildNext.dst_data_locs)
  return &dst_data_locs_;
}
inline const ::es_proto::MemLoc& IEBuildNext::dst_data_locs(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.IEBuildNext.dst_data_locs)
  return dst_data_locs_.Get(index);
}
inline ::es_proto::MemLoc* IEBuildNext::add_dst_data_locs() {
  // @@protoc_insertion_point(field_add:es_proto.IEBuildNext.dst_data_locs)
  return dst_data_locs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >&
IEBuildNext::dst_data_locs() const {
  // @@protoc_insertion_point(field_list:es_proto.IEBuildNext.dst_data_locs)
  return dst_data_locs_;
}

// -------------------------------------------------------------------

// IERandom

// repeated .es_proto.MemLoc mems = 1;
inline int IERandom::mems_size() const {
  return mems_.size();
}
inline void IERandom::clear_mems() {
  mems_.Clear();
}
inline ::es_proto::MemLoc* IERandom::mutable_mems(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.IERandom.mems)
  return mems_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >*
IERandom::mutable_mems() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.IERandom.mems)
  return &mems_;
}
inline const ::es_proto::MemLoc& IERandom::mems(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.IERandom.mems)
  return mems_.Get(index);
}
inline ::es_proto::MemLoc* IERandom::add_mems() {
  // @@protoc_insertion_point(field_add:es_proto.IERandom.mems)
  return mems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::MemLoc >&
IERandom::mems() const {
  // @@protoc_insertion_point(field_list:es_proto.IERandom.mems)
  return mems_;
}

// -------------------------------------------------------------------

// InferenceEvent

// optional .es_proto.IEInit init = 1;
inline bool InferenceEvent::has_init() const {
  return op_case() == kInit;
}
inline void InferenceEvent::set_has_init() {
  _oneof_case_[0] = kInit;
}
inline void InferenceEvent::clear_init() {
  if (has_init()) {
    delete op_.init_;
    clear_has_op();
  }
}
inline const ::es_proto::IEInit& InferenceEvent::_internal_init() const {
  return *op_.init_;
}
inline ::es_proto::IEInit* InferenceEvent::release_init() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.init)
  if (has_init()) {
    clear_has_op();
      ::es_proto::IEInit* temp = op_.init_;
    op_.init_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IEInit& InferenceEvent::init() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.init)
  return has_init()
      ? *op_.init_
      : *reinterpret_cast< ::es_proto::IEInit*>(&::es_proto::_IEInit_default_instance_);
}
inline ::es_proto::IEInit* InferenceEvent::mutable_init() {
  if (!has_init()) {
    clear_op();
    set_has_init();
    op_.init_ = CreateMaybeMessage< ::es_proto::IEInit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.init)
  return op_.init_;
}

// optional .es_proto.IECloseReaders close_readers = 2;
inline bool InferenceEvent::has_close_readers() const {
  return op_case() == kCloseReaders;
}
inline void InferenceEvent::set_has_close_readers() {
  _oneof_case_[0] = kCloseReaders;
}
inline void InferenceEvent::clear_close_readers() {
  if (has_close_readers()) {
    delete op_.close_readers_;
    clear_has_op();
  }
}
inline const ::es_proto::IECloseReaders& InferenceEvent::_internal_close_readers() const {
  return *op_.close_readers_;
}
inline ::es_proto::IECloseReaders* InferenceEvent::release_close_readers() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.close_readers)
  if (has_close_readers()) {
    clear_has_op();
      ::es_proto::IECloseReaders* temp = op_.close_readers_;
    op_.close_readers_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IECloseReaders& InferenceEvent::close_readers() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.close_readers)
  return has_close_readers()
      ? *op_.close_readers_
      : *reinterpret_cast< ::es_proto::IECloseReaders*>(&::es_proto::_IECloseReaders_default_instance_);
}
inline ::es_proto::IECloseReaders* InferenceEvent::mutable_close_readers() {
  if (!has_close_readers()) {
    clear_op();
    set_has_close_readers();
    op_.close_readers_ = CreateMaybeMessage< ::es_proto::IECloseReaders >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.close_readers)
  return op_.close_readers_;
}

// optional .es_proto.IELoadWeight load_weight = 3;
inline bool InferenceEvent::has_load_weight() const {
  return op_case() == kLoadWeight;
}
inline void InferenceEvent::set_has_load_weight() {
  _oneof_case_[0] = kLoadWeight;
}
inline void InferenceEvent::clear_load_weight() {
  if (has_load_weight()) {
    delete op_.load_weight_;
    clear_has_op();
  }
}
inline const ::es_proto::IELoadWeight& InferenceEvent::_internal_load_weight() const {
  return *op_.load_weight_;
}
inline ::es_proto::IELoadWeight* InferenceEvent::release_load_weight() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.load_weight)
  if (has_load_weight()) {
    clear_has_op();
      ::es_proto::IELoadWeight* temp = op_.load_weight_;
    op_.load_weight_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IELoadWeight& InferenceEvent::load_weight() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.load_weight)
  return has_load_weight()
      ? *op_.load_weight_
      : *reinterpret_cast< ::es_proto::IELoadWeight*>(&::es_proto::_IELoadWeight_default_instance_);
}
inline ::es_proto::IELoadWeight* InferenceEvent::mutable_load_weight() {
  if (!has_load_weight()) {
    clear_op();
    set_has_load_weight();
    op_.load_weight_ = CreateMaybeMessage< ::es_proto::IELoadWeight >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.load_weight)
  return op_.load_weight_;
}

// optional .es_proto.IELoadDataMatrix load_data_matrix = 4;
inline bool InferenceEvent::has_load_data_matrix() const {
  return op_case() == kLoadDataMatrix;
}
inline void InferenceEvent::set_has_load_data_matrix() {
  _oneof_case_[0] = kLoadDataMatrix;
}
inline void InferenceEvent::clear_load_data_matrix() {
  if (has_load_data_matrix()) {
    delete op_.load_data_matrix_;
    clear_has_op();
  }
}
inline const ::es_proto::IELoadDataMatrix& InferenceEvent::_internal_load_data_matrix() const {
  return *op_.load_data_matrix_;
}
inline ::es_proto::IELoadDataMatrix* InferenceEvent::release_load_data_matrix() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.load_data_matrix)
  if (has_load_data_matrix()) {
    clear_has_op();
      ::es_proto::IELoadDataMatrix* temp = op_.load_data_matrix_;
    op_.load_data_matrix_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IELoadDataMatrix& InferenceEvent::load_data_matrix() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.load_data_matrix)
  return has_load_data_matrix()
      ? *op_.load_data_matrix_
      : *reinterpret_cast< ::es_proto::IELoadDataMatrix*>(&::es_proto::_IELoadDataMatrix_default_instance_);
}
inline ::es_proto::IELoadDataMatrix* InferenceEvent::mutable_load_data_matrix() {
  if (!has_load_data_matrix()) {
    clear_op();
    set_has_load_data_matrix();
    op_.load_data_matrix_ = CreateMaybeMessage< ::es_proto::IELoadDataMatrix >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.load_data_matrix)
  return op_.load_data_matrix_;
}

// optional .es_proto.IELoadMask load_mask = 5;
inline bool InferenceEvent::has_load_mask() const {
  return op_case() == kLoadMask;
}
inline void InferenceEvent::set_has_load_mask() {
  _oneof_case_[0] = kLoadMask;
}
inline void InferenceEvent::clear_load_mask() {
  if (has_load_mask()) {
    delete op_.load_mask_;
    clear_has_op();
  }
}
inline const ::es_proto::IELoadMask& InferenceEvent::_internal_load_mask() const {
  return *op_.load_mask_;
}
inline ::es_proto::IELoadMask* InferenceEvent::release_load_mask() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.load_mask)
  if (has_load_mask()) {
    clear_has_op();
      ::es_proto::IELoadMask* temp = op_.load_mask_;
    op_.load_mask_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IELoadMask& InferenceEvent::load_mask() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.load_mask)
  return has_load_mask()
      ? *op_.load_mask_
      : *reinterpret_cast< ::es_proto::IELoadMask*>(&::es_proto::_IELoadMask_default_instance_);
}
inline ::es_proto::IELoadMask* InferenceEvent::mutable_load_mask() {
  if (!has_load_mask()) {
    clear_op();
    set_has_load_mask();
    op_.load_mask_ = CreateMaybeMessage< ::es_proto::IELoadMask >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.load_mask)
  return op_.load_mask_;
}

// optional .es_proto.IELoadFreqsCis load_freqs_cis = 6;
inline bool InferenceEvent::has_load_freqs_cis() const {
  return op_case() == kLoadFreqsCis;
}
inline void InferenceEvent::set_has_load_freqs_cis() {
  _oneof_case_[0] = kLoadFreqsCis;
}
inline void InferenceEvent::clear_load_freqs_cis() {
  if (has_load_freqs_cis()) {
    delete op_.load_freqs_cis_;
    clear_has_op();
  }
}
inline const ::es_proto::IELoadFreqsCis& InferenceEvent::_internal_load_freqs_cis() const {
  return *op_.load_freqs_cis_;
}
inline ::es_proto::IELoadFreqsCis* InferenceEvent::release_load_freqs_cis() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.load_freqs_cis)
  if (has_load_freqs_cis()) {
    clear_has_op();
      ::es_proto::IELoadFreqsCis* temp = op_.load_freqs_cis_;
    op_.load_freqs_cis_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IELoadFreqsCis& InferenceEvent::load_freqs_cis() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.load_freqs_cis)
  return has_load_freqs_cis()
      ? *op_.load_freqs_cis_
      : *reinterpret_cast< ::es_proto::IELoadFreqsCis*>(&::es_proto::_IELoadFreqsCis_default_instance_);
}
inline ::es_proto::IELoadFreqsCis* InferenceEvent::mutable_load_freqs_cis() {
  if (!has_load_freqs_cis()) {
    clear_op();
    set_has_load_freqs_cis();
    op_.load_freqs_cis_ = CreateMaybeMessage< ::es_proto::IELoadFreqsCis >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.load_freqs_cis)
  return op_.load_freqs_cis_;
}

// optional .es_proto.IEExecute execute = 7;
inline bool InferenceEvent::has_execute() const {
  return op_case() == kExecute;
}
inline void InferenceEvent::set_has_execute() {
  _oneof_case_[0] = kExecute;
}
inline void InferenceEvent::clear_execute() {
  if (has_execute()) {
    delete op_.execute_;
    clear_has_op();
  }
}
inline const ::es_proto::IEExecute& InferenceEvent::_internal_execute() const {
  return *op_.execute_;
}
inline ::es_proto::IEExecute* InferenceEvent::release_execute() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.execute)
  if (has_execute()) {
    clear_has_op();
      ::es_proto::IEExecute* temp = op_.execute_;
    op_.execute_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IEExecute& InferenceEvent::execute() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.execute)
  return has_execute()
      ? *op_.execute_
      : *reinterpret_cast< ::es_proto::IEExecute*>(&::es_proto::_IEExecute_default_instance_);
}
inline ::es_proto::IEExecute* InferenceEvent::mutable_execute() {
  if (!has_execute()) {
    clear_op();
    set_has_execute();
    op_.execute_ = CreateMaybeMessage< ::es_proto::IEExecute >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.execute)
  return op_.execute_;
}

// optional .es_proto.IEBuildNext build_next = 8;
inline bool InferenceEvent::has_build_next() const {
  return op_case() == kBuildNext;
}
inline void InferenceEvent::set_has_build_next() {
  _oneof_case_[0] = kBuildNext;
}
inline void InferenceEvent::clear_build_next() {
  if (has_build_next()) {
    delete op_.build_next_;
    clear_has_op();
  }
}
inline const ::es_proto::IEBuildNext& InferenceEvent::_internal_build_next() const {
  return *op_.build_next_;
}
inline ::es_proto::IEBuildNext* InferenceEvent::release_build_next() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.build_next)
  if (has_build_next()) {
    clear_has_op();
      ::es_proto::IEBuildNext* temp = op_.build_next_;
    op_.build_next_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IEBuildNext& InferenceEvent::build_next() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.build_next)
  return has_build_next()
      ? *op_.build_next_
      : *reinterpret_cast< ::es_proto::IEBuildNext*>(&::es_proto::_IEBuildNext_default_instance_);
}
inline ::es_proto::IEBuildNext* InferenceEvent::mutable_build_next() {
  if (!has_build_next()) {
    clear_op();
    set_has_build_next();
    op_.build_next_ = CreateMaybeMessage< ::es_proto::IEBuildNext >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.build_next)
  return op_.build_next_;
}

// optional .es_proto.IERandom random = 9;
inline bool InferenceEvent::has_random() const {
  return op_case() == kRandom;
}
inline void InferenceEvent::set_has_random() {
  _oneof_case_[0] = kRandom;
}
inline void InferenceEvent::clear_random() {
  if (has_random()) {
    delete op_.random_;
    clear_has_op();
  }
}
inline const ::es_proto::IERandom& InferenceEvent::_internal_random() const {
  return *op_.random_;
}
inline ::es_proto::IERandom* InferenceEvent::release_random() {
  // @@protoc_insertion_point(field_release:es_proto.InferenceEvent.random)
  if (has_random()) {
    clear_has_op();
      ::es_proto::IERandom* temp = op_.random_;
    op_.random_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::es_proto::IERandom& InferenceEvent::random() const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvent.random)
  return has_random()
      ? *op_.random_
      : *reinterpret_cast< ::es_proto::IERandom*>(&::es_proto::_IERandom_default_instance_);
}
inline ::es_proto::IERandom* InferenceEvent::mutable_random() {
  if (!has_random()) {
    clear_op();
    set_has_random();
    op_.random_ = CreateMaybeMessage< ::es_proto::IERandom >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvent.random)
  return op_.random_;
}

inline bool InferenceEvent::has_op() const {
  return op_case() != OP_NOT_SET;
}
inline void InferenceEvent::clear_has_op() {
  _oneof_case_[0] = OP_NOT_SET;
}
inline InferenceEvent::OpCase InferenceEvent::op_case() const {
  return InferenceEvent::OpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InferenceEvents

// repeated .es_proto.InferenceEvent event = 1;
inline int InferenceEvents::event_size() const {
  return event_.size();
}
inline void InferenceEvents::clear_event() {
  event_.Clear();
}
inline ::es_proto::InferenceEvent* InferenceEvents::mutable_event(int index) {
  // @@protoc_insertion_point(field_mutable:es_proto.InferenceEvents.event)
  return event_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::es_proto::InferenceEvent >*
InferenceEvents::mutable_event() {
  // @@protoc_insertion_point(field_mutable_list:es_proto.InferenceEvents.event)
  return &event_;
}
inline const ::es_proto::InferenceEvent& InferenceEvents::event(int index) const {
  // @@protoc_insertion_point(field_get:es_proto.InferenceEvents.event)
  return event_.Get(index);
}
inline ::es_proto::InferenceEvent* InferenceEvents::add_event() {
  // @@protoc_insertion_point(field_add:es_proto.InferenceEvents.event)
  return event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::es_proto::InferenceEvent >&
InferenceEvents::event() const {
  // @@protoc_insertion_point(field_list:es_proto.InferenceEvents.event)
  return event_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace es_proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_einsummable_2eproto
